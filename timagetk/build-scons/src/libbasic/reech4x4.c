/*************************************************************************
 * reech4x4.c -
 *
 * $Id: reech4x4.begin,v 1.3 2001/12/10 08:45:17 greg Exp $
 *
 * Copyright (c) INRIA 1999
 *
 * AUTHOR:
 * Gregoire Malandain (greg@sophia.inria.fr)
 *
 * CREATION DATE:
 *
 *
 * ADDITIONS, CHANGES
 *
 *
 *
 *
 */


/* CAUTION
   DO NOT EDIT THIS FILE,
   UNLESS YOU HAVE A VERY GOOD REASON
 */

#include <stdio.h>
#include <stdlib.h>

#include <typedefs.h>
#include <chunks.h>

#include <reech4x4.h>



#define _CONVERTR_(R) ( R )
#define _CONVERTI_(R) ( (R) >= 0.0 ? ((int)((R)+0.5)) : ((int)((R)-0.5)) )
static int _verbose_ = 1;




void setVerboseInReech4x4( int v )
{
  _verbose_ = v;
}

void incrementVerboseInReech4x4(  )
{
  _verbose_ ++;
}

void decrementVerboseInReech4x4(  )
{
  _verbose_ --;
  if ( _verbose_ < 0 ) _verbose_ = 0;
}





typedef struct {
  void* theBuf; /* buffer to be resampled */
  int *theDim; /* dimensions of this buffer */
  void* resBuf; /* result buffer */
  int *resDim;  /* dimensions of this buffer */
  double* mat;   /* transformation matrix */
  float gain;
  float bias;
} _LinearResamplingParam;





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   (double* mat) is the matrix which permits to get
   from resBuf into theBuf.
   If one only have the matrix from theBuf into resBuf,
   it must be inverted first.

   Soit x le point transforme et ix=(int)x;
   nous allons distinguer les cas suivants :
    x < -0.5               => resultat = 0
    -0.5 <= x < 0.0        => ix=0, on n'interpole pas selon X
    0.0 < x && ix < dimx-1 => on interpole selon X
    x < dimx-0.5           => ix=dimx-1, on n'interpole pas selon X
    x >= dimx-0.5          => resultat = 0

*/

static void *_Reech3DTriLin4x4_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;


  double* mat = p->mat;

  size_t i, j, k;
  register int ix, iy, iz;


  register double x, y, z, dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  register double res;
  double v6, v5, v4;
  size_t rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register double ddimz = (double)tdimz-0.5;
  register u8 *tbuf = (u8*)theBuf;
  register u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;
  size_t iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	if ((z <= -0.5) || ( z >= ddimz)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	tpt = (u8 *)tbuf;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) &&
	     (z > 0.0) && (iz < t1dimz) ) {
	  /* the corresponding point is in the box defined
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;

	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;

	  res = 0;
	  res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	  tpt --;
	  res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	  tpt -= t1dimx;
	  res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	  tpt --;
	  res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	  tpt -= toffset2;
	  res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	  tpt --;
	  res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	  tpt -= t1dimx;
	  res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	  tpt --;
	  res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	/* here, we are sure we are on some border */
	tpt += ix + iy * tdimx + iz * tdimxy;
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    if ( (z < 0.0) || (iz == t1dimz) ) {
	      *rbuf = *tpt;
	      continue;
	    }
	    dz = z - iz;
	    res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	    tpt += tdimxy;
	    res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	    *rbuf = (u8)_CONVERTI_( res );
	    continue;
	  }
	  dy = y - iy;
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	    tpt += tdimx;
	    res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	    *rbuf = (u8)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	  tpt += toffset2+1;
	  res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt += tdimx;
	  res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	/* here we are sure that the border is either
	   along the Y or the Z axis */
	dx = x - ix;
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	    tpt ++;
	    res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	    *rbuf = (u8)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  tpt += tdimxy-1;
	  res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt ++;
	  res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	/* here we are sure that the border is along the Z axis */
	dy = y - iy;
	res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += t1dimx;
	res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt ++;
	res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
	*rbuf = (u8)_CONVERTI_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech3DTriLin4x4_u8 ( void* theBuf, /* buffer to be resampled */
			     int *theDim, /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     double* mat   /* transformation matrix */
			     )
{
  char *proc = "Reech3DTriLin4x4_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLin4x4_u8, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech3DTriLin4x4gb_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;
  float gain = p->gain;
  float bias = p->bias;

  register int i, j, k, ix, iy, iz;
  register double x, y, z, dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  register double res;
  double v6, v5, v4;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register double ddimz = (double)tdimz-0.5;
  register u8 *tbuf = (u8*)theBuf;
  register u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;
  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	if ((z <= -0.5) || ( z >= ddimz)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	tpt = (u8 *)tbuf;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) &&
	     (z > 0.0) && (iz < t1dimz) ) {
	  /* the corresponding point is in the box defined
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;

	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;

	  res = 0;
	  res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	  tpt --;
	  res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	  tpt -= t1dimx;
	  res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	  tpt --;
	  res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	  tpt -= toffset2;
	  res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	  tpt --;
	  res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	  tpt -= t1dimx;
	  res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	  tpt --;
	  res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	  res = res * g + b;
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	/* here, we are sure we are on some border */
	tpt += ix + iy * tdimx + iz * tdimxy;
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    if ( (z < 0.0) || (iz == t1dimz) ) {
	      res = (double)(*tpt) * g + b;
	      *rbuf = (u8)_CONVERTI_( res );
	      continue;
	    }
	    dz = z - iz;
	    res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	    tpt += tdimxy;
	    res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	    res = res * g + b;
	    *rbuf = (u8)_CONVERTI_( res );
	    continue;
	  }
	  dy = y - iy;
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	    tpt += tdimx;
	    res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	    res = res * g + b;
	    *rbuf = (u8)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	  tpt += toffset2+1;
	  res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt += tdimx;
	  res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	  res = res * g + b;
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	/* here we are sure that the border is either
	   along the Y or the Z axis */
	dx = x - ix;
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	    tpt ++;
	    res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	    res = res * g + b;
	    *rbuf = (u8)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  tpt += tdimxy-1;
	  res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt ++;
	  res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	  res = res * g + b;
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	/* here we are sure that the border is along the Z axis */
	dy = y - iy;
	res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += t1dimx;
	res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt ++;
	res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
	res = res * g + b;
	*rbuf = (u8)_CONVERTI_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech3DTriLin4x4gb_u8 ( void* theBuf, /* buffer to be resampled */
			       int *theDim, /* dimensions of this buffer */
			       void* resBuf, /* result buffer */
			       int *resDim,  /* dimensions of this buffer */
			       double* mat,   /* transformation matrix */
			       float gain,
			       float bias )
{
  char *proc = "Reech3DTriLin4x4gb_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLin4x4gb_u8, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech3DNearest4x4_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  register int i, j, k, ix, iy, iz;
  register double x, y, z;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;
  register u8 *tbuf = (u8*)theBuf;
  register u8 *rbuf = (u8*)resBuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	ix = (int)(x+0.5);
	if (( x <= -0.5 ) || ( ix > t1dimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	iy = (int)(y+0.5);
	if (( y <= -0.5 ) || ( iy > t1dimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	iz = (int)(z+0.5);
	if (( z <= -0.5 ) || ( iz > t1dimz)) { *rbuf = 0; continue; }

	*rbuf = tbuf[ ix + iy * tdimx + iz * tdimxy ];
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech3DNearest4x4_u8 ( void* theBuf, /* buffer to be resampled */
			      int *theDim,  /* dimensions of this buffer */
			      void* resBuf, /* result buffer */
			      int *resDim,  /* dimensions of this buffer */
			      double* mat   /* transformation matrix */
			      )
{
  char *proc = "Reech3DNearest4x4_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DNearest4x4_u8, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech2DTriLin4x4_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  register int i, j, k, ix, iy;
  register double x, y, dx, dy, dxdy;
  register double res, v;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1];
  int toffset=tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register u8 *tbuf = (u8*)theBuf;
  register u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    /* tbuf represente le premier point du plan */
    tbuf  = (u8*)theBuf;
    tbuf += k*(tdimx * tdimy);
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j +              mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j +              mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	tpt = (u8 *)tbuf;
	tpt += ix + iy * tdimx;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) ) {
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1)
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1)
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  )
	  */
	  v = dy-dxdy;
	  res = 0;
	  res += (1-dx-v) * (*tpt);  /* tbuf(ix  ,iy  ) */
	  tpt ++;
	  res += (dx-dxdy) * (*tpt); /* tbuf(ix+1,iy  ) */
	  tpt += toffset;
	  res += v * (*tpt);       /* tbuf(ix,iy+1  ) */
	  tpt ++;
	  res += dxdy * (*tpt);      /* tbuf(ix+1,iy+1) */
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}

	/* here, we are sure we are on some border */
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  /* we just look at y */
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    *rbuf = *tpt;
	    continue;
	  }
	  dy = y - iy;
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	dx = x - ix;
	res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
	tpt ++;
	res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
	*rbuf = (u8)_CONVERTI_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech2DTriLin4x4_u8 ( void* theBuf, /* buffer to be resampled */
			     int *theDim, /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     double* mat   /* transformation matrix */
			     )
{
  char *proc = "Reech2DTriLin4x4_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLin4x4_u8, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech2DTriLin4x4gb_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;
  float gain = p->gain;
  float bias = p->bias;

  register int i, j, k, ix, iy;
  register double x, y, dx, dy, dxdy;
  register double res, v;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1];
  int toffset=tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register u8 *tbuf = (u8*)theBuf;
  register u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;
  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    /* tbuf represente le premier point du plan */
    tbuf  = (u8*)theBuf;
    tbuf += k*(tdimx * tdimy);
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j +              mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j +              mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	tpt = (u8 *)tbuf;
	tpt += ix + iy * tdimx;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) ) {
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1)
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1)
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  )
	  */
	  v = dy-dxdy;
	  res = 0;
	  res += (1-dx-v) * (*tpt);  /* tbuf(ix  ,iy  ) */
	  tpt ++;
	  res += (dx-dxdy) * (*tpt); /* tbuf(ix+1,iy  ) */
	  tpt += toffset;
	  res += v * (*tpt);       /* tbuf(ix,iy+1  ) */
	  tpt ++;
	  res += dxdy * (*tpt);      /* tbuf(ix+1,iy+1) */
	  res = res * g + b;
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}

	/* here, we are sure we are on some border */
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  /* we just look at y */
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    res = (double)(*tpt) * g + b;
	    *rbuf = (u8)_CONVERTI_( res );
	    continue;
	  }
	  dy = y - iy;
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	  res = (double)(*tpt) * g + b;
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	dx = x - ix;
	res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
	tpt ++;
	res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
	res = res * g + b;
	*rbuf = (u8)_CONVERTI_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech2DTriLin4x4gb_u8 ( void* theBuf, /* buffer to be resampled */
			       int *theDim, /* dimensions of this buffer */
			       void* resBuf, /* result buffer */
			       int *resDim,  /* dimensions of this buffer */
			       double* mat,   /* transformation matrix */
			       float gain,
			       float bias )
{
  char *proc = "Reech2DTriLin4x4gb_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLin4x4gb_u8, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech2DNearest4x4_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  register int i, j, k, ix, iy;
  register double x, y;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1];
  register int t1dimx=tdimx-1, t1dimy=tdimy-1;
  register u8 *tbuf = (u8*)theBuf;
  register u8 *rbuf = (u8*)resBuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    /* tbuf represente le premier point du plan */
    tbuf  = (u8*)theBuf;
    tbuf += k*(tdimx * tdimy);
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[3];
	ix = (int)(x+0.5);
	if (( x <= -0.5 ) || ( ix > t1dimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[7];
	iy = (int)(y+0.5);
	if (( y <= -0.5 ) || ( iy > t1dimy)) { *rbuf = 0; continue; }

	*rbuf = tbuf[ ix + iy * tdimx ];
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech2DNearest4x4_u8 ( void* theBuf, /* buffer to be resampled */
			      int *theDim,  /* dimensions of this buffer */
			      void* resBuf, /* result buffer */
			      int *resDim,  /* dimensions of this buffer */
			      double* mat   /* transformation matrix */
			      )
{
  char *proc = "Reech2DNearest4x4_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DNearest4x4_u8, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   (double* mat) is the matrix which permits to get
   from resBuf into theBuf.
   If one only have the matrix from theBuf into resBuf,
   it must be inverted first.

   Soit x le point transforme et ix=(int)x;
   nous allons distinguer les cas suivants :
    x < -0.5               => resultat = 0
    -0.5 <= x < 0.0        => ix=0, on n'interpole pas selon X
    0.0 < x && ix < dimx-1 => on interpole selon X
    x < dimx-0.5           => ix=dimx-1, on n'interpole pas selon X
    x >= dimx-0.5          => resultat = 0

*/

static void *_Reech3DTriLin4x4_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  size_t i, j, k;
  register int ix, iy, iz;
  register double x, y, z, dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  register double res;
  double v6, v5, v4;
  size_t rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register double ddimz = (double)tdimz-0.5;
  register s8 *tbuf = (s8*)theBuf;
  register s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;
  size_t iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	if ((z <= -0.5) || ( z >= ddimz)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	tpt = (s8 *)tbuf;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) &&
	     (z > 0.0) && (iz < t1dimz) ) {
	  /* the corresponding point is in the box defined
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;

	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;

	  res = 0;
	  res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	  tpt --;
	  res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	  tpt -= t1dimx;
	  res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	  tpt --;
	  res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	  tpt -= toffset2;
	  res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	  tpt --;
	  res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	  tpt -= t1dimx;
	  res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	  tpt --;
	  res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	/* here, we are sure we are on some border */
	tpt += ix + iy * tdimx + iz * tdimxy;
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    if ( (z < 0.0) || (iz == t1dimz) ) {
	      *rbuf = *tpt;
	      continue;
	    }
	    dz = z - iz;
	    res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	    tpt += tdimxy;
	    res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	    *rbuf = (s8)_CONVERTI_( res );
	    continue;
	  }
	  dy = y - iy;
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	    tpt += tdimx;
	    res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	    *rbuf = (s8)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	  tpt += toffset2+1;
	  res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt += tdimx;
	  res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	/* here we are sure that the border is either
	   along the Y or the Z axis */
	dx = x - ix;
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	    tpt ++;
	    res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	    *rbuf = (s8)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  tpt += tdimxy-1;
	  res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt ++;
	  res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	/* here we are sure that the border is along the Z axis */
	dy = y - iy;
	res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += t1dimx;
	res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt ++;
	res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
	*rbuf = (s8)_CONVERTI_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech3DTriLin4x4_s8 ( void* theBuf, /* buffer to be resampled */
			     int *theDim, /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     double* mat   /* transformation matrix */
			     )
{
  char *proc = "Reech3DTriLin4x4_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLin4x4_s8, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech3DTriLin4x4gb_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;
  float gain = p->gain;
  float bias = p->bias;

  register int i, j, k, ix, iy, iz;
  register double x, y, z, dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  register double res;
  double v6, v5, v4;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register double ddimz = (double)tdimz-0.5;
  register s8 *tbuf = (s8*)theBuf;
  register s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;
  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	if ((z <= -0.5) || ( z >= ddimz)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	tpt = (s8 *)tbuf;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) &&
	     (z > 0.0) && (iz < t1dimz) ) {
	  /* the corresponding point is in the box defined
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;

	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;

	  res = 0;
	  res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	  tpt --;
	  res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	  tpt -= t1dimx;
	  res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	  tpt --;
	  res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	  tpt -= toffset2;
	  res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	  tpt --;
	  res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	  tpt -= t1dimx;
	  res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	  tpt --;
	  res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	  res = res * g + b;
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	/* here, we are sure we are on some border */
	tpt += ix + iy * tdimx + iz * tdimxy;
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    if ( (z < 0.0) || (iz == t1dimz) ) {
	      res = (double)(*tpt) * g + b;
	      *rbuf = (s8)_CONVERTI_( res );
	      continue;
	    }
	    dz = z - iz;
	    res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	    tpt += tdimxy;
	    res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	    res = res * g + b;
	    *rbuf = (s8)_CONVERTI_( res );
	    continue;
	  }
	  dy = y - iy;
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	    tpt += tdimx;
	    res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	    res = res * g + b;
	    *rbuf = (s8)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	  tpt += toffset2+1;
	  res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt += tdimx;
	  res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	  res = res * g + b;
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	/* here we are sure that the border is either
	   along the Y or the Z axis */
	dx = x - ix;
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	    tpt ++;
	    res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	    res = res * g + b;
	    *rbuf = (s8)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  tpt += tdimxy-1;
	  res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt ++;
	  res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	  res = res * g + b;
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	/* here we are sure that the border is along the Z axis */
	dy = y - iy;
	res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += t1dimx;
	res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt ++;
	res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
	res = res * g + b;
	*rbuf = (s8)_CONVERTI_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech3DTriLin4x4gb_s8 ( void* theBuf, /* buffer to be resampled */
			       int *theDim, /* dimensions of this buffer */
			       void* resBuf, /* result buffer */
			       int *resDim,  /* dimensions of this buffer */
			       double* mat,   /* transformation matrix */
			       float gain,
			       float bias )
{
  char *proc = "Reech3DTriLin4x4gb_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLin4x4gb_s8, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech3DNearest4x4_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  register int i, j, k, ix, iy, iz;
  register double x, y, z;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;
  register s8 *tbuf = (s8*)theBuf;
  register s8 *rbuf = (s8*)resBuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	ix = (int)(x+0.5);
	if (( x <= -0.5 ) || ( ix > t1dimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	iy = (int)(y+0.5);
	if (( y <= -0.5 ) || ( iy > t1dimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	iz = (int)(z+0.5);
	if (( z <= -0.5 ) || ( iz > t1dimz)) { *rbuf = 0; continue; }

	*rbuf = tbuf[ ix + iy * tdimx + iz * tdimxy ];
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech3DNearest4x4_s8 ( void* theBuf, /* buffer to be resampled */
			      int *theDim,  /* dimensions of this buffer */
			      void* resBuf, /* result buffer */
			      int *resDim,  /* dimensions of this buffer */
			      double* mat   /* transformation matrix */
			      )
{
  char *proc = "Reech3DNearest4x4_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DNearest4x4_s8, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech2DTriLin4x4_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  register int i, j, k, ix, iy;
  register double x, y, dx, dy, dxdy;
  register double res, v;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1];
  int toffset=tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register s8 *tbuf = (s8*)theBuf;
  register s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    /* tbuf represente le premier point du plan */
    tbuf  = (s8*)theBuf;
    tbuf += k*(tdimx * tdimy);
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j +              mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j +              mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	tpt = (s8 *)tbuf;
	tpt += ix + iy * tdimx;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) ) {
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1)
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1)
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  )
	  */
	  v = dy-dxdy;
	  res = 0;
	  res += (1-dx-v) * (*tpt);  /* tbuf(ix  ,iy  ) */
	  tpt ++;
	  res += (dx-dxdy) * (*tpt); /* tbuf(ix+1,iy  ) */
	  tpt += toffset;
	  res += v * (*tpt);       /* tbuf(ix,iy+1  ) */
	  tpt ++;
	  res += dxdy * (*tpt);      /* tbuf(ix+1,iy+1) */
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}

	/* here, we are sure we are on some border */
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  /* we just look at y */
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    *rbuf = *tpt;
	    continue;
	  }
	  dy = y - iy;
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	dx = x - ix;
	res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
	tpt ++;
	res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
	*rbuf = (s8)_CONVERTI_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech2DTriLin4x4_s8 ( void* theBuf, /* buffer to be resampled */
			     int *theDim, /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     double* mat   /* transformation matrix */
			     )
{
  char *proc = "Reech2DTriLin4x4_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLin4x4_s8, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech2DTriLin4x4gb_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;
  float gain = p->gain;
  float bias = p->bias;

  register int i, j, k, ix, iy;
  register double x, y, dx, dy, dxdy;
  register double res, v;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1];
  int toffset=tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register s8 *tbuf = (s8*)theBuf;
  register s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;
  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    /* tbuf represente le premier point du plan */
    tbuf  = (s8*)theBuf;
    tbuf += k*(tdimx * tdimy);
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j +              mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j +              mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	tpt = (s8 *)tbuf;
	tpt += ix + iy * tdimx;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) ) {
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1)
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1)
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  )
	  */
	  v = dy-dxdy;
	  res = 0;
	  res += (1-dx-v) * (*tpt);  /* tbuf(ix  ,iy  ) */
	  tpt ++;
	  res += (dx-dxdy) * (*tpt); /* tbuf(ix+1,iy  ) */
	  tpt += toffset;
	  res += v * (*tpt);       /* tbuf(ix,iy+1  ) */
	  tpt ++;
	  res += dxdy * (*tpt);      /* tbuf(ix+1,iy+1) */
	  res = res * g + b;
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}

	/* here, we are sure we are on some border */
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  /* we just look at y */
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    res = (double)(*tpt) * g + b;
	    *rbuf = (s8)_CONVERTI_( res );
	    continue;
	  }
	  dy = y - iy;
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	  res = (double)(*tpt) * g + b;
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	dx = x - ix;
	res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
	tpt ++;
	res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
	res = res * g + b;
	*rbuf = (s8)_CONVERTI_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech2DTriLin4x4gb_s8 ( void* theBuf, /* buffer to be resampled */
			       int *theDim, /* dimensions of this buffer */
			       void* resBuf, /* result buffer */
			       int *resDim,  /* dimensions of this buffer */
			       double* mat,   /* transformation matrix */
			       float gain,
			       float bias )
{
  char *proc = "Reech2DTriLin4x4gb_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLin4x4gb_s8, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech2DNearest4x4_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  register int i, j, k, ix, iy;
  register double x, y;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1];
  register int t1dimx=tdimx-1, t1dimy=tdimy-1;
  register s8 *tbuf = (s8*)theBuf;
  register s8 *rbuf = (s8*)resBuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    /* tbuf represente le premier point du plan */
    tbuf  = (s8*)theBuf;
    tbuf += k*(tdimx * tdimy);
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[3];
	ix = (int)(x+0.5);
	if (( x <= -0.5 ) || ( ix > t1dimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[7];
	iy = (int)(y+0.5);
	if (( y <= -0.5 ) || ( iy > t1dimy)) { *rbuf = 0; continue; }

	*rbuf = tbuf[ ix + iy * tdimx ];
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech2DNearest4x4_s8 ( void* theBuf, /* buffer to be resampled */
			      int *theDim,  /* dimensions of this buffer */
			      void* resBuf, /* result buffer */
			      int *resDim,  /* dimensions of this buffer */
			      double* mat   /* transformation matrix */
			      )
{
  char *proc = "Reech2DNearest4x4_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DNearest4x4_s8, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   (double* mat) is the matrix which permits to get
   from resBuf into theBuf.
   If one only have the matrix from theBuf into resBuf,
   it must be inverted first.

   Soit x le point transforme et ix=(int)x;
   nous allons distinguer les cas suivants :
    x < -0.5               => resultat = 0
    -0.5 <= x < 0.0        => ix=0, on n'interpole pas selon X
    0.0 < x && ix < dimx-1 => on interpole selon X
    x < dimx-0.5           => ix=dimx-1, on n'interpole pas selon X
    x >= dimx-0.5          => resultat = 0

*/

static void *_Reech3DTriLin4x4_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  size_t i, j, k;
  register int ix, iy, iz;
  register double x, y, z, dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  register double res;
  double v6, v5, v4;
  size_t rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register double ddimz = (double)tdimz-0.5;
  register u16 *tbuf = (u16*)theBuf;
  register u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;
  size_t iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	if ((z <= -0.5) || ( z >= ddimz)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	tpt = (u16 *)tbuf;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) &&
	     (z > 0.0) && (iz < t1dimz) ) {
	  /* the corresponding point is in the box defined
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;

	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;

	  res = 0;
	  res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	  tpt --;
	  res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	  tpt -= t1dimx;
	  res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	  tpt --;
	  res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	  tpt -= toffset2;
	  res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	  tpt --;
	  res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	  tpt -= t1dimx;
	  res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	  tpt --;
	  res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	/* here, we are sure we are on some border */
	tpt += ix + iy * tdimx + iz * tdimxy;
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    if ( (z < 0.0) || (iz == t1dimz) ) {
	      *rbuf = *tpt;
	      continue;
	    }
	    dz = z - iz;
	    res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	    tpt += tdimxy;
	    res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	    *rbuf = (u16)_CONVERTI_( res );
	    continue;
	  }
	  dy = y - iy;
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	    tpt += tdimx;
	    res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	    *rbuf = (u16)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	  tpt += toffset2+1;
	  res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt += tdimx;
	  res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	/* here we are sure that the border is either
	   along the Y or the Z axis */
	dx = x - ix;
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	    tpt ++;
	    res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	    *rbuf = (u16)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  tpt += tdimxy-1;
	  res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt ++;
	  res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	/* here we are sure that the border is along the Z axis */
	dy = y - iy;
	res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += t1dimx;
	res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt ++;
	res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
	*rbuf = (u16)_CONVERTI_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech3DTriLin4x4_u16 ( void* theBuf, /* buffer to be resampled */
			     int *theDim, /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     double* mat   /* transformation matrix */
			     )
{
  char *proc = "Reech3DTriLin4x4_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLin4x4_u16, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech3DTriLin4x4gb_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;
  float gain = p->gain;
  float bias = p->bias;

  register int i, j, k, ix, iy, iz;
  register double x, y, z, dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  register double res;
  double v6, v5, v4;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register double ddimz = (double)tdimz-0.5;
  register u16 *tbuf = (u16*)theBuf;
  register u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;
  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	if ((z <= -0.5) || ( z >= ddimz)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	tpt = (u16 *)tbuf;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) &&
	     (z > 0.0) && (iz < t1dimz) ) {
	  /* the corresponding point is in the box defined
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;

	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;

	  res = 0;
	  res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	  tpt --;
	  res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	  tpt -= t1dimx;
	  res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	  tpt --;
	  res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	  tpt -= toffset2;
	  res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	  tpt --;
	  res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	  tpt -= t1dimx;
	  res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	  tpt --;
	  res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	  res = res * g + b;
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	/* here, we are sure we are on some border */
	tpt += ix + iy * tdimx + iz * tdimxy;
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    if ( (z < 0.0) || (iz == t1dimz) ) {
	      res = (double)(*tpt) * g + b;
	      *rbuf = (u16)_CONVERTI_( res );
	      continue;
	    }
	    dz = z - iz;
	    res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	    tpt += tdimxy;
	    res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	    res = res * g + b;
	    *rbuf = (u16)_CONVERTI_( res );
	    continue;
	  }
	  dy = y - iy;
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	    tpt += tdimx;
	    res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	    res = res * g + b;
	    *rbuf = (u16)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	  tpt += toffset2+1;
	  res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt += tdimx;
	  res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	  res = res * g + b;
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	/* here we are sure that the border is either
	   along the Y or the Z axis */
	dx = x - ix;
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	    tpt ++;
	    res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	    res = res * g + b;
	    *rbuf = (u16)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  tpt += tdimxy-1;
	  res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt ++;
	  res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	  res = res * g + b;
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	/* here we are sure that the border is along the Z axis */
	dy = y - iy;
	res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += t1dimx;
	res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt ++;
	res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
	res = res * g + b;
	*rbuf = (u16)_CONVERTI_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech3DTriLin4x4gb_u16 ( void* theBuf, /* buffer to be resampled */
			       int *theDim, /* dimensions of this buffer */
			       void* resBuf, /* result buffer */
			       int *resDim,  /* dimensions of this buffer */
			       double* mat,   /* transformation matrix */
			       float gain,
			       float bias )
{
  char *proc = "Reech3DTriLin4x4gb_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLin4x4gb_u16, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech3DNearest4x4_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  register int i, j, k, ix, iy, iz;
  register double x, y, z;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;
  register u16 *tbuf = (u16*)theBuf;
  register u16 *rbuf = (u16*)resBuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	ix = (int)(x+0.5);
	if (( x <= -0.5 ) || ( ix > t1dimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	iy = (int)(y+0.5);
	if (( y <= -0.5 ) || ( iy > t1dimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	iz = (int)(z+0.5);
	if (( z <= -0.5 ) || ( iz > t1dimz)) { *rbuf = 0; continue; }

	*rbuf = tbuf[ ix + iy * tdimx + iz * tdimxy ];
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech3DNearest4x4_u16 ( void* theBuf, /* buffer to be resampled */
			      int *theDim,  /* dimensions of this buffer */
			      void* resBuf, /* result buffer */
			      int *resDim,  /* dimensions of this buffer */
			      double* mat   /* transformation matrix */
			      )
{
  char *proc = "Reech3DNearest4x4_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DNearest4x4_u16, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech2DTriLin4x4_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  register int i, j, k, ix, iy;
  register double x, y, dx, dy, dxdy;
  register double res, v;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1];
  int toffset=tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register u16 *tbuf = (u16*)theBuf;
  register u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    /* tbuf represente le premier point du plan */
    tbuf  = (u16*)theBuf;
    tbuf += k*(tdimx * tdimy);
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j +              mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j +              mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	tpt = (u16 *)tbuf;
	tpt += ix + iy * tdimx;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) ) {
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1)
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1)
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  )
	  */
	  v = dy-dxdy;
	  res = 0;
	  res += (1-dx-v) * (*tpt);  /* tbuf(ix  ,iy  ) */
	  tpt ++;
	  res += (dx-dxdy) * (*tpt); /* tbuf(ix+1,iy  ) */
	  tpt += toffset;
	  res += v * (*tpt);       /* tbuf(ix,iy+1  ) */
	  tpt ++;
	  res += dxdy * (*tpt);      /* tbuf(ix+1,iy+1) */
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}

	/* here, we are sure we are on some border */
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  /* we just look at y */
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    *rbuf = *tpt;
	    continue;
	  }
	  dy = y - iy;
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	dx = x - ix;
	res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
	tpt ++;
	res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
	*rbuf = (u16)_CONVERTI_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech2DTriLin4x4_u16 ( void* theBuf, /* buffer to be resampled */
			     int *theDim, /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     double* mat   /* transformation matrix */
			     )
{
  char *proc = "Reech2DTriLin4x4_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLin4x4_u16, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech2DTriLin4x4gb_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;
  float gain = p->gain;
  float bias = p->bias;

  register int i, j, k, ix, iy;
  register double x, y, dx, dy, dxdy;
  register double res, v;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1];
  int toffset=tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register u16 *tbuf = (u16*)theBuf;
  register u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;
  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    /* tbuf represente le premier point du plan */
    tbuf  = (u16*)theBuf;
    tbuf += k*(tdimx * tdimy);
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j +              mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j +              mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	tpt = (u16 *)tbuf;
	tpt += ix + iy * tdimx;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) ) {
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1)
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1)
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  )
	  */
	  v = dy-dxdy;
	  res = 0;
	  res += (1-dx-v) * (*tpt);  /* tbuf(ix  ,iy  ) */
	  tpt ++;
	  res += (dx-dxdy) * (*tpt); /* tbuf(ix+1,iy  ) */
	  tpt += toffset;
	  res += v * (*tpt);       /* tbuf(ix,iy+1  ) */
	  tpt ++;
	  res += dxdy * (*tpt);      /* tbuf(ix+1,iy+1) */
	  res = res * g + b;
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}

	/* here, we are sure we are on some border */
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  /* we just look at y */
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    res = (double)(*tpt) * g + b;
	    *rbuf = (u16)_CONVERTI_( res );
	    continue;
	  }
	  dy = y - iy;
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	  res = (double)(*tpt) * g + b;
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	dx = x - ix;
	res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
	tpt ++;
	res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
	res = res * g + b;
	*rbuf = (u16)_CONVERTI_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech2DTriLin4x4gb_u16 ( void* theBuf, /* buffer to be resampled */
			       int *theDim, /* dimensions of this buffer */
			       void* resBuf, /* result buffer */
			       int *resDim,  /* dimensions of this buffer */
			       double* mat,   /* transformation matrix */
			       float gain,
			       float bias )
{
  char *proc = "Reech2DTriLin4x4gb_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLin4x4gb_u16, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech2DNearest4x4_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  register int i, j, k, ix, iy;
  register double x, y;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1];
  register int t1dimx=tdimx-1, t1dimy=tdimy-1;
  register u16 *tbuf = (u16*)theBuf;
  register u16 *rbuf = (u16*)resBuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    /* tbuf represente le premier point du plan */
    tbuf  = (u16*)theBuf;
    tbuf += k*(tdimx * tdimy);
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[3];
	ix = (int)(x+0.5);
	if (( x <= -0.5 ) || ( ix > t1dimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[7];
	iy = (int)(y+0.5);
	if (( y <= -0.5 ) || ( iy > t1dimy)) { *rbuf = 0; continue; }

	*rbuf = tbuf[ ix + iy * tdimx ];
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech2DNearest4x4_u16 ( void* theBuf, /* buffer to be resampled */
			      int *theDim,  /* dimensions of this buffer */
			      void* resBuf, /* result buffer */
			      int *resDim,  /* dimensions of this buffer */
			      double* mat   /* transformation matrix */
			      )
{
  char *proc = "Reech2DNearest4x4_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DNearest4x4_u16, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   (double* mat) is the matrix which permits to get
   from resBuf into theBuf.
   If one only have the matrix from theBuf into resBuf,
   it must be inverted first.

   Soit x le point transforme et ix=(int)x;
   nous allons distinguer les cas suivants :
    x < -0.5               => resultat = 0
    -0.5 <= x < 0.0        => ix=0, on n'interpole pas selon X
    0.0 < x && ix < dimx-1 => on interpole selon X
    x < dimx-0.5           => ix=dimx-1, on n'interpole pas selon X
    x >= dimx-0.5          => resultat = 0

*/

static void *_Reech3DTriLin4x4_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  size_t i, j, k;
  register int ix, iy, iz;
  register double x, y, z, dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  register double res;
  double v6, v5, v4;
  size_t rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register double ddimz = (double)tdimz-0.5;
  register s16 *tbuf = (s16*)theBuf;
  register s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;
  size_t iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	if ((z <= -0.5) || ( z >= ddimz)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	tpt = (s16 *)tbuf;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) &&
	     (z > 0.0) && (iz < t1dimz) ) {
	  /* the corresponding point is in the box defined
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;

	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;

	  res = 0;
	  res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	  tpt --;
	  res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	  tpt -= t1dimx;
	  res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	  tpt --;
	  res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	  tpt -= toffset2;
	  res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	  tpt --;
	  res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	  tpt -= t1dimx;
	  res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	  tpt --;
	  res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	/* here, we are sure we are on some border */
	tpt += ix + iy * tdimx + iz * tdimxy;
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    if ( (z < 0.0) || (iz == t1dimz) ) {
	      *rbuf = *tpt;
	      continue;
	    }
	    dz = z - iz;
	    res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	    tpt += tdimxy;
	    res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	    *rbuf = (s16)_CONVERTI_( res );
	    continue;
	  }
	  dy = y - iy;
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	    tpt += tdimx;
	    res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	    *rbuf = (s16)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	  tpt += toffset2+1;
	  res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt += tdimx;
	  res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	/* here we are sure that the border is either
	   along the Y or the Z axis */
	dx = x - ix;
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	    tpt ++;
	    res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	    *rbuf = (s16)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  tpt += tdimxy-1;
	  res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt ++;
	  res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	/* here we are sure that the border is along the Z axis */
	dy = y - iy;
	res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += t1dimx;
	res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt ++;
	res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
	*rbuf = (s16)_CONVERTI_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech3DTriLin4x4_s16 ( void* theBuf, /* buffer to be resampled */
			     int *theDim, /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     double* mat   /* transformation matrix */
			     )
{
  char *proc = "Reech3DTriLin4x4_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLin4x4_s16, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech3DTriLin4x4gb_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;
  float gain = p->gain;
  float bias = p->bias;

  register int i, j, k, ix, iy, iz;
  register double x, y, z, dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  register double res;
  double v6, v5, v4;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register double ddimz = (double)tdimz-0.5;
  register s16 *tbuf = (s16*)theBuf;
  register s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;
  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	if ((z <= -0.5) || ( z >= ddimz)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	tpt = (s16 *)tbuf;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) &&
	     (z > 0.0) && (iz < t1dimz) ) {
	  /* the corresponding point is in the box defined
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;

	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;

	  res = 0;
	  res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	  tpt --;
	  res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	  tpt -= t1dimx;
	  res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	  tpt --;
	  res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	  tpt -= toffset2;
	  res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	  tpt --;
	  res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	  tpt -= t1dimx;
	  res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	  tpt --;
	  res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	  res = res * g + b;
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	/* here, we are sure we are on some border */
	tpt += ix + iy * tdimx + iz * tdimxy;
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    if ( (z < 0.0) || (iz == t1dimz) ) {
	      res = (double)(*tpt) * g + b;
	      *rbuf = (s16)_CONVERTI_( res );
	      continue;
	    }
	    dz = z - iz;
	    res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	    tpt += tdimxy;
	    res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	    res = res * g + b;
	    *rbuf = (s16)_CONVERTI_( res );
	    continue;
	  }
	  dy = y - iy;
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	    tpt += tdimx;
	    res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	    res = res * g + b;
	    *rbuf = (s16)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	  tpt += toffset2+1;
	  res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt += tdimx;
	  res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	  res = res * g + b;
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	/* here we are sure that the border is either
	   along the Y or the Z axis */
	dx = x - ix;
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	    tpt ++;
	    res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	    res = res * g + b;
	    *rbuf = (s16)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  tpt += tdimxy-1;
	  res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt ++;
	  res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	  res = res * g + b;
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	/* here we are sure that the border is along the Z axis */
	dy = y - iy;
	res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += t1dimx;
	res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt ++;
	res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
	res = res * g + b;
	*rbuf = (s16)_CONVERTI_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech3DTriLin4x4gb_s16 ( void* theBuf, /* buffer to be resampled */
			       int *theDim, /* dimensions of this buffer */
			       void* resBuf, /* result buffer */
			       int *resDim,  /* dimensions of this buffer */
			       double* mat,   /* transformation matrix */
			       float gain,
			       float bias )
{
  char *proc = "Reech3DTriLin4x4gb_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLin4x4gb_s16, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech3DNearest4x4_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  register int i, j, k, ix, iy, iz;
  register double x, y, z;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;
  register s16 *tbuf = (s16*)theBuf;
  register s16 *rbuf = (s16*)resBuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	ix = (int)(x+0.5);
	if (( x <= -0.5 ) || ( ix > t1dimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	iy = (int)(y+0.5);
	if (( y <= -0.5 ) || ( iy > t1dimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	iz = (int)(z+0.5);
	if (( z <= -0.5 ) || ( iz > t1dimz)) { *rbuf = 0; continue; }

	*rbuf = tbuf[ ix + iy * tdimx + iz * tdimxy ];
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech3DNearest4x4_s16 ( void* theBuf, /* buffer to be resampled */
			      int *theDim,  /* dimensions of this buffer */
			      void* resBuf, /* result buffer */
			      int *resDim,  /* dimensions of this buffer */
			      double* mat   /* transformation matrix */
			      )
{
  char *proc = "Reech3DNearest4x4_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DNearest4x4_s16, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech2DTriLin4x4_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  register int i, j, k, ix, iy;
  register double x, y, dx, dy, dxdy;
  register double res, v;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1];
  int toffset=tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register s16 *tbuf = (s16*)theBuf;
  register s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    /* tbuf represente le premier point du plan */
    tbuf  = (s16*)theBuf;
    tbuf += k*(tdimx * tdimy);
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j +              mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j +              mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	tpt = (s16 *)tbuf;
	tpt += ix + iy * tdimx;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) ) {
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1)
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1)
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  )
	  */
	  v = dy-dxdy;
	  res = 0;
	  res += (1-dx-v) * (*tpt);  /* tbuf(ix  ,iy  ) */
	  tpt ++;
	  res += (dx-dxdy) * (*tpt); /* tbuf(ix+1,iy  ) */
	  tpt += toffset;
	  res += v * (*tpt);       /* tbuf(ix,iy+1  ) */
	  tpt ++;
	  res += dxdy * (*tpt);      /* tbuf(ix+1,iy+1) */
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}

	/* here, we are sure we are on some border */
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  /* we just look at y */
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    *rbuf = *tpt;
	    continue;
	  }
	  dy = y - iy;
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	dx = x - ix;
	res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
	tpt ++;
	res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
	*rbuf = (s16)_CONVERTI_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech2DTriLin4x4_s16 ( void* theBuf, /* buffer to be resampled */
			     int *theDim, /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     double* mat   /* transformation matrix */
			     )
{
  char *proc = "Reech2DTriLin4x4_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLin4x4_s16, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech2DTriLin4x4gb_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;
  float gain = p->gain;
  float bias = p->bias;

  register int i, j, k, ix, iy;
  register double x, y, dx, dy, dxdy;
  register double res, v;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1];
  int toffset=tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register s16 *tbuf = (s16*)theBuf;
  register s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;
  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    /* tbuf represente le premier point du plan */
    tbuf  = (s16*)theBuf;
    tbuf += k*(tdimx * tdimy);
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j +              mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j +              mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	tpt = (s16 *)tbuf;
	tpt += ix + iy * tdimx;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) ) {
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1)
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1)
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  )
	  */
	  v = dy-dxdy;
	  res = 0;
	  res += (1-dx-v) * (*tpt);  /* tbuf(ix  ,iy  ) */
	  tpt ++;
	  res += (dx-dxdy) * (*tpt); /* tbuf(ix+1,iy  ) */
	  tpt += toffset;
	  res += v * (*tpt);       /* tbuf(ix,iy+1  ) */
	  tpt ++;
	  res += dxdy * (*tpt);      /* tbuf(ix+1,iy+1) */
	  res = res * g + b;
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}

	/* here, we are sure we are on some border */
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  /* we just look at y */
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    res = (double)(*tpt) * g + b;
	    *rbuf = (s16)_CONVERTI_( res );
	    continue;
	  }
	  dy = y - iy;
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	  res = (double)(*tpt) * g + b;
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	dx = x - ix;
	res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
	tpt ++;
	res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
	res = res * g + b;
	*rbuf = (s16)_CONVERTI_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech2DTriLin4x4gb_s16 ( void* theBuf, /* buffer to be resampled */
			       int *theDim, /* dimensions of this buffer */
			       void* resBuf, /* result buffer */
			       int *resDim,  /* dimensions of this buffer */
			       double* mat,   /* transformation matrix */
			       float gain,
			       float bias )
{
  char *proc = "Reech2DTriLin4x4gb_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLin4x4gb_s16, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech2DNearest4x4_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  register int i, j, k, ix, iy;
  register double x, y;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1];
  register int t1dimx=tdimx-1, t1dimy=tdimy-1;
  register s16 *tbuf = (s16*)theBuf;
  register s16 *rbuf = (s16*)resBuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    /* tbuf represente le premier point du plan */
    tbuf  = (s16*)theBuf;
    tbuf += k*(tdimx * tdimy);
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[3];
	ix = (int)(x+0.5);
	if (( x <= -0.5 ) || ( ix > t1dimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[7];
	iy = (int)(y+0.5);
	if (( y <= -0.5 ) || ( iy > t1dimy)) { *rbuf = 0; continue; }

	*rbuf = tbuf[ ix + iy * tdimx ];
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech2DNearest4x4_s16 ( void* theBuf, /* buffer to be resampled */
			      int *theDim,  /* dimensions of this buffer */
			      void* resBuf, /* result buffer */
			      int *resDim,  /* dimensions of this buffer */
			      double* mat   /* transformation matrix */
			      )
{
  char *proc = "Reech2DNearest4x4_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DNearest4x4_s16, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   (double* mat) is the matrix which permits to get
   from resBuf into theBuf.
   If one only have the matrix from theBuf into resBuf,
   it must be inverted first.

   Soit x le point transforme et ix=(int)x;
   nous allons distinguer les cas suivants :
    x < -0.5               => resultat = 0
    -0.5 <= x < 0.0        => ix=0, on n'interpole pas selon X
    0.0 < x && ix < dimx-1 => on interpole selon X
    x < dimx-0.5           => ix=dimx-1, on n'interpole pas selon X
    x >= dimx-0.5          => resultat = 0

*/

static void *_Reech3DTriLin4x4_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  size_t i, j, k;
  register int ix, iy, iz;
  register double x, y, z, dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  register double res;
  double v6, v5, v4;
  size_t rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register double ddimz = (double)tdimz-0.5;
  register r32 *tbuf = (r32*)theBuf;
  register r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  size_t ifirst, jfirst, kfirst;
  size_t ilast, jlast, klast;
  size_t iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %lu\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	if ((z <= -0.5) || ( z >= ddimz)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	tpt = (r32 *)tbuf;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) &&
	     (z > 0.0) && (iz < t1dimz) ) {
	  /* the corresponding point is in the box defined
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;

	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;

	  res = 0;
	  res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	  tpt --;
	  res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	  tpt -= t1dimx;
	  res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	  tpt --;
	  res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	  tpt -= toffset2;
	  res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	  tpt --;
	  res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	  tpt -= t1dimx;
	  res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	  tpt --;
	  res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	/* here, we are sure we are on some border */
	tpt += ix + iy * tdimx + iz * tdimxy;
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    if ( (z < 0.0) || (iz == t1dimz) ) {
	      *rbuf = *tpt;
	      continue;
	    }
	    dz = z - iz;
	    res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	    tpt += tdimxy;
	    res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	    *rbuf = (r32)_CONVERTR_( res );
	    continue;
	  }
	  dy = y - iy;
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	    tpt += tdimx;
	    res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	    *rbuf = (r32)_CONVERTR_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	  tpt += toffset2+1;
	  res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt += tdimx;
	  res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	/* here we are sure that the border is either
	   along the Y or the Z axis */
	dx = x - ix;
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	    tpt ++;
	    res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	    *rbuf = (r32)_CONVERTR_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  tpt += tdimxy-1;
	  res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt ++;
	  res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	/* here we are sure that the border is along the Z axis */
	dy = y - iy;
	res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += t1dimx;
	res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt ++;
	res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
	*rbuf = (r32)_CONVERTR_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech3DTriLin4x4_r32 ( void* theBuf, /* buffer to be resampled */
			     int *theDim, /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     double* mat   /* transformation matrix */
			     )
{
  char *proc = "Reech3DTriLin4x4_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLin4x4_r32, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech3DTriLin4x4gb_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;
  float gain = p->gain;
  float bias = p->bias;

  register int i, j, k, ix, iy, iz;
  register double x, y, z, dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  register double res;
  double v6, v5, v4;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register double ddimz = (double)tdimz-0.5;
  register r32 *tbuf = (r32*)theBuf;
  register r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;
  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	if ((z <= -0.5) || ( z >= ddimz)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	tpt = (r32 *)tbuf;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) &&
	     (z > 0.0) && (iz < t1dimz) ) {
	  /* the corresponding point is in the box defined
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;

	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;

	  res = 0;
	  res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	  tpt --;
	  res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	  tpt -= t1dimx;
	  res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	  tpt --;
	  res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	  tpt -= toffset2;
	  res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	  tpt --;
	  res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	  tpt -= t1dimx;
	  res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	  tpt --;
	  res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	  res = res * g + b;
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	/* here, we are sure we are on some border */
	tpt += ix + iy * tdimx + iz * tdimxy;
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    if ( (z < 0.0) || (iz == t1dimz) ) {
	      res = (double)(*tpt) * g + b;
	      *rbuf = (r32)_CONVERTR_( res );
	      continue;
	    }
	    dz = z - iz;
	    res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	    tpt += tdimxy;
	    res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	    res = res * g + b;
	    *rbuf = (r32)_CONVERTR_( res );
	    continue;
	  }
	  dy = y - iy;
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	    tpt += tdimx;
	    res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	    res = res * g + b;
	    *rbuf = (r32)_CONVERTR_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	  tpt += toffset2+1;
	  res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt += tdimx;
	  res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	  res = res * g + b;
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	/* here we are sure that the border is either
	   along the Y or the Z axis */
	dx = x - ix;
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	    tpt ++;
	    res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	    res = res * g + b;
	    *rbuf = (r32)_CONVERTR_( res );
	    continue;
	  }
	  dz = z - iz;
	  res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  tpt += tdimxy-1;
	  res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	  tpt ++;
	  res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	  res = res * g + b;
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	/* here we are sure that the border is along the Z axis */
	dy = y - iy;
	res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += t1dimx;
	res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt ++;
	res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
	res = res * g + b;
	*rbuf = (r32)_CONVERTR_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech3DTriLin4x4gb_r32 ( void* theBuf, /* buffer to be resampled */
			       int *theDim, /* dimensions of this buffer */
			       void* resBuf, /* result buffer */
			       int *resDim,  /* dimensions of this buffer */
			       double* mat,   /* transformation matrix */
			       float gain,
			       float bias )
{
  char *proc = "Reech3DTriLin4x4gb_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DTriLin4x4gb_r32, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech3DNearest4x4_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  register int i, j, k, ix, iy, iz;
  register double x, y, z;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;
  register r32 *tbuf = (r32*)theBuf;
  register r32 *rbuf = (r32*)resBuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[2] * k + mat[3];
	ix = (int)(x+0.5);
	if (( x <= -0.5 ) || ( ix > t1dimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[6] * k + mat[7];
	iy = (int)(y+0.5);
	if (( y <= -0.5 ) || ( iy > t1dimy)) { *rbuf = 0; continue; }
	z = mat[8] * i +  mat[9] * j + mat[10] * k + mat[11];
	iz = (int)(z+0.5);
	if (( z <= -0.5 ) || ( iz > t1dimz)) { *rbuf = 0; continue; }

	*rbuf = tbuf[ ix + iy * tdimx + iz * tdimxy ];
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech3DNearest4x4_r32 ( void* theBuf, /* buffer to be resampled */
			      int *theDim,  /* dimensions of this buffer */
			      void* resBuf, /* result buffer */
			      int *resDim,  /* dimensions of this buffer */
			      double* mat   /* transformation matrix */
			      )
{
  char *proc = "Reech3DNearest4x4_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech3DNearest4x4_r32, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech2DTriLin4x4_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  register int i, j, k, ix, iy;
  register double x, y, dx, dy, dxdy;
  register double res, v;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1];
  int toffset=tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register r32 *tbuf = (r32*)theBuf;
  register r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    /* tbuf represente le premier point du plan */
    tbuf  = (r32*)theBuf;
    tbuf += k*(tdimx * tdimy);
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j +              mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j +              mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	tpt = (r32 *)tbuf;
	tpt += ix + iy * tdimx;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) ) {
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1)
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1)
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  )
	  */
	  v = dy-dxdy;
	  res = 0;
	  res += (1-dx-v) * (*tpt);  /* tbuf(ix  ,iy  ) */
	  tpt ++;
	  res += (dx-dxdy) * (*tpt); /* tbuf(ix+1,iy  ) */
	  tpt += toffset;
	  res += v * (*tpt);       /* tbuf(ix,iy+1  ) */
	  tpt ++;
	  res += dxdy * (*tpt);      /* tbuf(ix+1,iy+1) */
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}

	/* here, we are sure we are on some border */
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  /* we just look at y */
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    *rbuf = *tpt;
	    continue;
	  }
	  dy = y - iy;
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	dx = x - ix;
	res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
	tpt ++;
	res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
	*rbuf = (r32)_CONVERTR_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech2DTriLin4x4_r32 ( void* theBuf, /* buffer to be resampled */
			     int *theDim, /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     double* mat   /* transformation matrix */
			     )
{
  char *proc = "Reech2DTriLin4x4_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLin4x4_r32, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech2DTriLin4x4gb_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;
  float gain = p->gain;
  float bias = p->bias;

  register int i, j, k, ix, iy;
  register double x, y, dx, dy, dxdy;
  register double res, v;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1];
  int toffset=tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register r32 *tbuf = (r32*)theBuf;
  register r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;
  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    /* tbuf represente le premier point du plan */
    tbuf  = (r32*)theBuf;
    tbuf += k*(tdimx * tdimy);
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j +              mat[3];
	if ((x <= -0.5) || ( x >= ddimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j +              mat[7];
	if ((y <= -0.5) || ( y >= ddimy)) { *rbuf = 0; continue; }

	/* here, the point lies on the borders or completely inside
	   the image */
	ix = (int)x;
	iy = (int)y;
	tpt = (r32 *)tbuf;
	tpt += ix + iy * tdimx;

	/* are we on the border or not ? */
	if ( (x > 0.0) && (ix < t1dimx) &&
	     (y > 0.0) && (iy < t1dimy) ) {
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1)
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1)
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  )
	  */
	  v = dy-dxdy;
	  res = 0;
	  res += (1-dx-v) * (*tpt);  /* tbuf(ix  ,iy  ) */
	  tpt ++;
	  res += (dx-dxdy) * (*tpt); /* tbuf(ix+1,iy  ) */
	  tpt += toffset;
	  res += v * (*tpt);       /* tbuf(ix,iy+1  ) */
	  tpt ++;
	  res += dxdy * (*tpt);      /* tbuf(ix+1,iy+1) */
	  res = res * g + b;
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}

	/* here, we are sure we are on some border */
	if ( (x < 0.0) || (ix == t1dimx) ) {
	  /* we just look at y */
	  if ( (y < 0.0) || (iy == t1dimy) ) {
	    res = (double)(*tpt) * g + b;
	    *rbuf = (r32)_CONVERTR_( res );
	    continue;
	  }
	  dy = y - iy;
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	  res = (double)(*tpt) * g + b;
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	dx = x - ix;
	res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
	tpt ++;
	res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
	res = res * g + b;
	*rbuf = (r32)_CONVERTR_( res );
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech2DTriLin4x4gb_r32 ( void* theBuf, /* buffer to be resampled */
			       int *theDim, /* dimensions of this buffer */
			       void* resBuf, /* result buffer */
			       int *resDim,  /* dimensions of this buffer */
			       double* mat,   /* transformation matrix */
			       float gain,
			       float bias )
{
  char *proc = "Reech2DTriLin4x4gb_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DTriLin4x4gb_r32, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}





static void *_Reech2DNearest4x4_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _LinearResamplingParam *p = (_LinearResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  double* mat = p->mat;

  register int i, j, k, ix, iy;
  register double x, y;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1];
  register int t1dimx=tdimx-1, t1dimy=tdimy-1;
  register r32 *tbuf = (r32*)theBuf;
  register r32 *rbuf = (r32*)resBuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;
  int iend, jend;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );
    /* tbuf represente le premier point du plan */
    tbuf  = (r32*)theBuf;
    tbuf += k*(tdimx * tdimy);
    jend = (k==klast) ? jlast+1 : rdimy;
    for ( ; j<jend; j++, i=0 ) {
      iend = (j==jlast && k==klast) ? ilast+1 : rdimx;
      for ( ; i<iend; i++, rbuf++ ) {
	/* computation of the corresponding point coordinates in theBuf */
	x = mat[0] * i +  mat[1] * j + mat[3];
	ix = (int)(x+0.5);
	if (( x <= -0.5 ) || ( ix > t1dimx)) { *rbuf = 0; continue; }
	y = mat[4] * i +  mat[5] * j + mat[7];
	iy = (int)(y+0.5);
	if (( y <= -0.5 ) || ( iy > t1dimy)) { *rbuf = 0; continue; }

	*rbuf = tbuf[ ix + iy * tdimx ];
      }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





void Reech2DNearest4x4_r32 ( void* theBuf, /* buffer to be resampled */
			      int *theDim,  /* dimensions of this buffer */
			      void* resBuf, /* result buffer */
			      int *resDim,  /* dimensions of this buffer */
			      double* mat   /* transformation matrix */
			      )
{
  char *proc = "Reech2DNearest4x4_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _LinearResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.mat = mat;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ )
    chunks.data[i].parameters = (void*)(&p);

  /* processing
   */
  if ( processChunks( &_Reech2DNearest4x4_r32, &chunks, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to resample image\n", proc );
    freeChunks( &chunks );
    return;
  }

  freeChunks( &chunks );
}
