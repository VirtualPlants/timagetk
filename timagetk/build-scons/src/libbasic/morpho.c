/*************************************************************************
 * morpho.c -
 *
 * $Id: morpho.begin,v 1.2 2001/03/19 17:12:07 greg Exp $
 *
 * Copyright (c) INRIA 1999
 *
 * AUTHOR:
 * Gregoire Malandain (greg@sophia.inria.fr)
 * 
 * CREATION DATE: 
 * ???
 *
 *
 * ADDITIONS, CHANGES
 *
 *
 *
 */

/* CAUTION
   DO NOT EDIT THIS FILE,
   UNLESS YOU HAVE A VERY GOOD REASON 
 */


#include <morpho.h>








/* for binary operations only. With respect to grey-level operations,
   it seems that these operations are a little bit faster (a few percents
   on the CPU time), more experiments have to be conducted.
#define _TWO_OPS_( RES, A, B ) RES = ( ((int)(A)) | ((int)(B)) ) 
#define _ONE_OP_( RES, A )     RES = ( ((int)(RES)) | ((int)(A)) ) 
*/
/* for grey-level operations (works for binary operations too) */
/*
#define _TWO_OPS_( RES, A, B ) RES = ( (A) > (B) ? (A) : (B) )
#define _ONE_OP_( RES, A )     if ( (A) > (RES) ) RES = (A)
*/

/* 
   255
   if the result value is already set to this value
   there is nothing to be done.
   Because it makes the code longer and harder to read
   this test is only performed when at the center of 
   slices. */

/* Morphological operation :

   Binary -> [Binary | GreyLevel ]
           in case of Binary    => 1 == 1
	   in case of GreyLevel => 1 == 0
   Dilation -> [Erosion | Dilation]
           in case of Erosion  => > == '<'
	                          | == '&'
	   in case of Dilation => > == '>'
	                          | == '|'
	   
   4-connectivity: one pointer par neighbor

*/

void BinaryDilation_u8 ( void* inputBuf, /* buffer to be resampled */
			  void* resultBuf, /* result buffer */
			  int *theDim, /* dimensions of this buffer */
			  int connectivity, /* connectivity to be used */ 
			  int iterations  /* number of iterations */ )
{
  int conn = 0;                 /* "local" connectivity */
  u8 *localBuf = (void*)NULL; /* buffer for auxiliary computation */
  char *localTab[5];
  void *input;

  int dx, dy, dz, dx1, dy1, dz1;
  int dxy;
  int sliceSize, auxIntSize;
  register int x, y, z;
  int iter;

  if ( iterations <= 0 ) return;


  /* test on connectivity */
  conn = connectivity;
  switch ( conn ) {
  case 4 :
  case 8 :
  case 6 :
  case 10 :
  case 18 :
  case 26 :
    break ;
  default :
    conn = 26;
  }
  
  /* initialization */
  dx = theDim[0];   dx1 = dx - 1;
  dy = theDim[1];   dy1 = dy - 1;
  dz = theDim[2];   dz1 = dz - 1;
  dxy = dx * dy;

  if ( dz == 1 ) {
    switch ( conn ) {
    case 6 :
      conn = 4; break;
    case 10 :
    case 18 :
    case 26 :
      conn = 8; break;
    }
  }

  /* allocation of the auxiliary buffer 
     be sure that the size of each auxiliary slice is 
     a multiple of sizeof(int) for binary computation
   */
  sliceSize = dx * dy * sizeof(u8);
  auxIntSize = 1 + sliceSize / sizeof( int );
  localBuf = (void*)malloc( (unsigned int)(5 * auxIntSize * sizeof(int)) );
  if ( localBuf == (void*)NULL ) return;

  {
    char *t;
    for ( x = 0; x < 5; x ++ ) {
      t = (char*)localBuf;
      t += x * auxIntSize * sizeof( int );
      localTab[x] = (char*)t;
    }
  }

  input =  inputBuf;
  /* iterative processing */
  for ( iter = 0; iter < iterations; iter ++ ) {
    switch ( conn ) {

    /* 4-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 4 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	register u8 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register u8 *res;
	py -= dx;   px -= 1; 
	ny += dx;   nx += 1; 

	for ( z = 0; z < dz; z ++ ) {
	  res = (u8*)auxCurr;
	  /* first row */
	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; ny++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, res++ ) {
#if 1
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; ny++; res++;
	  py += dx;

	  /* middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 1
	    if ( *cur == 255 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
#if 1
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, res++ ) {
#if 1
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    }
#if 1
	    if ( *cur == 255 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
#if 1
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	  }

	  /* last row */
	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; py++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, res++ ) {
#if 1
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; py++; res++;
	  ny += dx;
	  /* copy */

	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
	}
      }
      break;
      
    /* 8-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X- or Y-lines
    */
    case 8 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	register u8 *px = cur;
	register u8 *cy, *py, *ny;
	register u8 *res;

	px -= 1;
	
	for ( z = 0; z < dz; z ++ ) {
	  /* computing along X */
	  res = (u8*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 1
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  py = cy = ny = (u8*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, resBuf++, cy++, ny++ )
	    *resBuf = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, resBuf++ ) {
#if 1
	    if ( *cy == 255 ) {
	      *resBuf = *cy;
	      continue;
	    }
#endif
	    *resBuf = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	    if ( (*py) > (*resBuf) ) *resBuf = (*py); /* _ONE_OP_( *resBuf, *py ); */
	  }
	  for ( x = 0; x < dx; x++, resBuf++, cy++, py++ ) 
	    *resBuf = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *resBuf, *cy, *py ); */
	}
      }
      break;
      

    /* 6-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 6 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	void *auxPrev = (void*)localTab[1];
	void *tmp;
	register u8 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register u8 *pz = cur, *nz = cur; 
	register u8 *res;

	pz -= dxy;   py -= dx;   px -= 1; 
	nz += dxy;   ny += dx;   nx += 1; 

	/* first slice */
	res = (u8*)auxCurr;
	/* first slice, first row */
	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, res++ ) {
#if 1
	  if ( *cur == 255 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;
	py += dx;

	/* first slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 1
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 1
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, res++ ) {
#if 1
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
#if 1
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 1
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	}

	/* first slice, last row */
	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, res++ ) {
#if 1
	  if ( *cur == 255 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;
	ny += dx; pz += dxy;
	tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	
	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  res = (u8*)auxCurr;
	  /* middle slice, first row */
#if 1
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 1
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, pz++, res++ ) {
#if 1
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 1
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 1
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  py += dx;
	  /* middle slice, middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 1
	    if ( *cur == 255 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 1
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, pz++, res++ ) {
#if 1
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    }
#if 1
	    if ( *cur == 255 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 1
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	  }
	  /* middle slice, last row */
#if 1
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 1
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, pz++, res++ ) {
#if 1
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 1
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 1
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  ny += dx;
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	}

	/* last slice */
	res = (u8*)auxCurr;
	/* last slice, first row */
	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, pz++, res++ ) {
#if 1
	  if ( *cur == 255 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;
	py += dx;

	/* last slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 1
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 1
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, pz++, res++ ) {
#if 1
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 1
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 1
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	}

	/* last slice, last row */
	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, pz++, res++ ) {
#if 1
	  if ( *cur == 255 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;
      
    /* 26-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X-, Y-lines
    */
    case 26 :
      /* les performances semblent moindres que celles de l'ancienne version
	 (en niveaux de gris), de l'ordre de 2 %
       */
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxNext = (void*)localTab[2];
	void *auxPrev = (void*)localTab[3];
	void *tmp;
	register u8 *px = cur;
	register u8 *cy, *py, *ny;
#if 1
	register int *ires, *ic, *in, *ip;
#else
	register u8 *cz, *pz, *nz;
#endif
	register u8 *res;

	px -= 1;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (u8*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 1
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u8*)auxCurr;
	py = cy = ny = (u8*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 1
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */

	/* second slice: 8-connectivity */
	/* computing along X */
	res = (u8*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 1
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u8*)auxNext;
	py = cy = ny = (u8*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x ++, cy++, ny++, py++, res++ ) {
#if 1
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	
	/* first slice: result 
	   if we cast slices of auxiliary buffer to be divided
	   by sizeof(int) we may use logical operations
	 */
#if 1
	ires = (int*)auxTmp; ic = (int*)auxCurr; in = (int*)auxNext;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ | *in++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	cz = (u8*)auxCurr;   nz = (u8*)auxNext;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) > (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif

	tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	
	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: 8-connectivity */
	  /* computing along X */
	  res = (u8*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 1
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (u8*)auxNext;
	  py = cy = ny = (u8*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 1
	    if ( *cy == 255 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  
#if 1
	  ires = (int*)auxTmp; ip = (int*)auxPrev;
	  ic = (int*)auxCurr; in = (int*)auxNext;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ires++ = *ic++ | *in++ | *ip++;
	  memcpy( (void*)resBuf, auxTmp, sliceSize );
	  resBuf += dxy;
#else
	  pz = (u8*)auxPrev;   cz = (u8*)auxCurr;
	  nz = (u8*)auxNext;
	  for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++, nz++ ) {
	    *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) > (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}

	/* last slice */
#if 1
	ires = (int*)auxTmp; ip = (int*)auxPrev; ic = (int*)auxCurr;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ | *ip++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	pz = (u8*)auxPrev;   cz = (u8*)auxCurr;
	for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++ )
	    *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    case 10 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxPrev = (void*)localTab[2];
	void *tmp;
	register u8 *px = cur;
	register u8 *cy, *py, *ny;
	register u8 *pz = cur, *nz = cur;
	register u8 *res;

	px -= 1;
	pz -= dxy;   nz += dxy;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (u8*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 1
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u8*)auxCurr;
	py = cy = ny = (u8*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 1
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (u8*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, nz++ )
	  if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	pz += dxy;
	tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;

	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* current slice: 8-connectivity */
	  /* computing along X */
	  res = (u8*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 1
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (u8*)auxCurr;
	  py = cy = ny = (u8*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 1
	    if ( *cy == 255 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* computing along Z */
	  res = (u8*)auxCurr;
	  for ( x = 0; x < dxy; x ++, res++, pz++, nz++ ) {
#if 1
	    if ( *res == 255 ) continue;
#endif
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;
	}

	/* last slice: 8-connectivity */
	/* computing along X */
	res = (u8*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 1
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u8*)auxCurr;
	py = cy = ny = (u8*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 1
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (u8*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, pz++ )
	  if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;

    case 18 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *aux4Prev = (void*)localTab[0];
	void *aux4Curr = (void*)localTab[1];
	void *aux4Next = (void*)localTab[2];
	void *auxCurr = (void*)localTab[3];
	void *auxNext = (void*)localTab[4];
	void *tmp;
	register u8 *px = cur;
	register u8 *ppy = cur, *nny = cur;
	register u8 *cy, *py, *ny;
#if 1
	register int *ic, *in, *ip;
#else
	register u8 *cz, *pz, *nz;
#endif
	register u8 *res;
	
	px -= 1;
	ppy -= dx;   nny += dx;

	/* first slice: computing along X */
	res = (u8*)aux4Curr;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 1
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* first slice: 8-connectivity: computing along Y */
	res = (u8*)auxCurr;
	py = cy = ny = (u8*)aux4Curr;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 1
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* first slice: 4-connectivity: computing along Y */
	res = (u8*)aux4Curr;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 1
	  if ( *res == 255 ) continue;
#endif
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;

	/* second slice: computing along X */
	res = (u8*)aux4Next;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 1
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* second slice: 8-connectivity: computing along Y */
	res = (u8*)auxNext;
	py = cy = ny = (u8*)aux4Next;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 1
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* second slice: 4-connectivity: computing along Y */
	res = (u8*)aux4Next;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 1
	  if ( *res == 255 ) continue;
#endif
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;
	
	/* first slice: result */
#if 1
	ic = (int*)auxCurr; in = (int*)aux4Next;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ |= *in++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
	resBuf += dxy;
#else
	cz = (u8*)auxCurr;   nz = (u8*)aux4Next;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) > (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif
	tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;

	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: computing along X */
	  res = (u8*)aux4Next;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 1
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* next slice: 8-connectivity: computing along Y */
	  res = (u8*)auxNext;
	  py = cy = ny = (u8*)aux4Next;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 1
	    if ( *cy == 255 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* next slice: 4-connectivity: computing along Y */
	  res = (u8*)aux4Next;
	  for ( x = 0; x < dx; x++, res++, nny++ )
	    if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  ppy += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 1
	    if ( *res == 255 ) continue;
#endif
	    if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	    if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  }
	  for ( x = 0; x < dx; x++, res++, ppy++ ) 
	    if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  nny += dx;
	  
	  /* current slice: result */
#if 1
	  ic = (int*)auxCurr; in = (int*)aux4Next; ip = (int*)aux4Prev;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ic++ |= *in++ | *ip++;
	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
#else
	  cz = (u8*)auxCurr;   nz = (u8*)aux4Next;
	  pz = (u8*)aux4Prev;
	  for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++, pz++ ) {
	    *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) > (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	  tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}
	
	/* last slice: result */
#if 1
	ic = (int*)auxCurr; ip = (int*)aux4Prev;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ |= *ip++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
#else
	cz = (u8*)auxCurr;   pz = (u8*)aux4Prev;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, pz++ )
	  *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    }
    input = resultBuf;
  }
  /* end */
  free( (void*)localBuf );
}

/* for binary operations only. With respect to grey-level operations,
   it seems that these operations are a little bit faster (a few percents
   on the CPU time), more experiments have to be conducted.
#define _TWO_OPS_( RES, A, B ) RES = ( ((int)(A)) | ((int)(B)) ) 
#define _ONE_OP_( RES, A )     RES = ( ((int)(RES)) | ((int)(A)) ) 
*/
/* for grey-level operations (works for binary operations too) */
/*
#define _TWO_OPS_( RES, A, B ) RES = ( (A) < (B) ? (A) : (B) )
#define _ONE_OP_( RES, A )     if ( (A) < (RES) ) RES = (A)
*/

/* 
   0
   if the result value is already set to this value
   there is nothing to be done.
   Because it makes the code longer and harder to read
   this test is only performed when at the center of 
   slices. */

/* Morphological operation :

   Binary -> [Binary | GreyLevel ]
           in case of Binary    => 1 == 1
	   in case of GreyLevel => 1 == 0
   Erosion -> [Erosion | Dilation]
           in case of Erosion  => < == '<'
	                          & == '&'
	   in case of Dilation => < == '>'
	                          & == '|'
	   
   4-connectivity: one pointer par neighbor

*/

void BinaryErosion_u8 ( void* inputBuf, /* buffer to be resampled */
			  void* resultBuf, /* result buffer */
			  int *theDim, /* dimensions of this buffer */
			  int connectivity, /* connectivity to be used */ 
			  int iterations  /* number of iterations */ )
{
  int conn = 0;                 /* "local" connectivity */
  u8 *localBuf = (void*)NULL; /* buffer for auxiliary computation */
  char *localTab[5];
  void *input;

  int dx, dy, dz, dx1, dy1, dz1;
  int dxy;
  int sliceSize, auxIntSize;
  register int x, y, z;
  int iter;

  if ( iterations <= 0 ) return;


  /* test on connectivity */
  conn = connectivity;
  switch ( conn ) {
  case 4 :
  case 8 :
  case 6 :
  case 10 :
  case 18 :
  case 26 :
    break ;
  default :
    conn = 26;
  }
  
  /* initialization */
  dx = theDim[0];   dx1 = dx - 1;
  dy = theDim[1];   dy1 = dy - 1;
  dz = theDim[2];   dz1 = dz - 1;
  dxy = dx * dy;

  if ( dz == 1 ) {
    switch ( conn ) {
    case 6 :
      conn = 4; break;
    case 10 :
    case 18 :
    case 26 :
      conn = 8; break;
    }
  }

  /* allocation of the auxiliary buffer 
     be sure that the size of each auxiliary slice is 
     a multiple of sizeof(int) for binary computation
   */
  sliceSize = dx * dy * sizeof(u8);
  auxIntSize = 1 + sliceSize / sizeof( int );
  localBuf = (void*)malloc( (unsigned int)(5 * auxIntSize * sizeof(int)) );
  if ( localBuf == (void*)NULL ) return;

  {
    char *t;
    for ( x = 0; x < 5; x ++ ) {
      t = (char*)localBuf;
      t += x * auxIntSize * sizeof( int );
      localTab[x] = (char*)t;
    }
  }

  input =  inputBuf;
  /* iterative processing */
  for ( iter = 0; iter < iterations; iter ++ ) {
    switch ( conn ) {

    /* 4-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 4 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	register u8 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register u8 *res;
	py -= dx;   px -= 1; 
	ny += dx;   nx += 1; 

	for ( z = 0; z < dz; z ++ ) {
	  res = (u8*)auxCurr;
	  /* first row */
	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; ny++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, res++ ) {
#if 1
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; ny++; res++;
	  py += dx;

	  /* middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 1
	    if ( *cur == 0 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
#if 1
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, res++ ) {
#if 1
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    }
#if 1
	    if ( *cur == 0 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
#if 1
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	  }

	  /* last row */
	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; py++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, res++ ) {
#if 1
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; py++; res++;
	  ny += dx;
	  /* copy */

	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
	}
      }
      break;
      
    /* 8-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X- or Y-lines
    */
    case 8 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	register u8 *px = cur;
	register u8 *cy, *py, *ny;
	register u8 *res;

	px -= 1;
	
	for ( z = 0; z < dz; z ++ ) {
	  /* computing along X */
	  res = (u8*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 1
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  py = cy = ny = (u8*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, resBuf++, cy++, ny++ )
	    *resBuf = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, resBuf++ ) {
#if 1
	    if ( *cy == 0 ) {
	      *resBuf = *cy;
	      continue;
	    }
#endif
	    *resBuf = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	    if ( (*py) < (*resBuf) ) *resBuf = (*py); /* _ONE_OP_( *resBuf, *py ); */
	  }
	  for ( x = 0; x < dx; x++, resBuf++, cy++, py++ ) 
	    *resBuf = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *resBuf, *cy, *py ); */
	}
      }
      break;
      

    /* 6-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 6 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	void *auxPrev = (void*)localTab[1];
	void *tmp;
	register u8 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register u8 *pz = cur, *nz = cur; 
	register u8 *res;

	pz -= dxy;   py -= dx;   px -= 1; 
	nz += dxy;   ny += dx;   nx += 1; 

	/* first slice */
	res = (u8*)auxCurr;
	/* first slice, first row */
	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, res++ ) {
#if 1
	  if ( *cur == 0 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;
	py += dx;

	/* first slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 1
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 1
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, res++ ) {
#if 1
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
#if 1
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 1
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	}

	/* first slice, last row */
	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, res++ ) {
#if 1
	  if ( *cur == 0 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;
	ny += dx; pz += dxy;
	tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	
	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  res = (u8*)auxCurr;
	  /* middle slice, first row */
#if 1
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 1
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, pz++, res++ ) {
#if 1
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 1
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 1
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  py += dx;
	  /* middle slice, middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 1
	    if ( *cur == 0 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 1
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, pz++, res++ ) {
#if 1
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    }
#if 1
	    if ( *cur == 0 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 1
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	  }
	  /* middle slice, last row */
#if 1
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 1
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, pz++, res++ ) {
#if 1
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 1
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 1
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  ny += dx;
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	}

	/* last slice */
	res = (u8*)auxCurr;
	/* last slice, first row */
	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, pz++, res++ ) {
#if 1
	  if ( *cur == 0 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;
	py += dx;

	/* last slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 1
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 1
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, pz++, res++ ) {
#if 1
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 1
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 1
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	}

	/* last slice, last row */
	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, pz++, res++ ) {
#if 1
	  if ( *cur == 0 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;
      
    /* 26-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X-, Y-lines
    */
    case 26 :
      /* les performances semblent moindres que celles de l'ancienne version
	 (en niveaux de gris), de l'ordre de 2 %
       */
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxNext = (void*)localTab[2];
	void *auxPrev = (void*)localTab[3];
	void *tmp;
	register u8 *px = cur;
	register u8 *cy, *py, *ny;
#if 1
	register int *ires, *ic, *in, *ip;
#else
	register u8 *cz, *pz, *nz;
#endif
	register u8 *res;

	px -= 1;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (u8*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 1
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u8*)auxCurr;
	py = cy = ny = (u8*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 1
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */

	/* second slice: 8-connectivity */
	/* computing along X */
	res = (u8*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 1
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u8*)auxNext;
	py = cy = ny = (u8*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x ++, cy++, ny++, py++, res++ ) {
#if 1
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	
	/* first slice: result 
	   if we cast slices of auxiliary buffer to be divided
	   by sizeof(int) we may use logical operations
	 */
#if 1
	ires = (int*)auxTmp; ic = (int*)auxCurr; in = (int*)auxNext;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ & *in++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	cz = (u8*)auxCurr;   nz = (u8*)auxNext;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) < (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif

	tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	
	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: 8-connectivity */
	  /* computing along X */
	  res = (u8*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 1
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (u8*)auxNext;
	  py = cy = ny = (u8*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 1
	    if ( *cy == 0 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  
#if 1
	  ires = (int*)auxTmp; ip = (int*)auxPrev;
	  ic = (int*)auxCurr; in = (int*)auxNext;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ires++ = *ic++ & *in++ & *ip++;
	  memcpy( (void*)resBuf, auxTmp, sliceSize );
	  resBuf += dxy;
#else
	  pz = (u8*)auxPrev;   cz = (u8*)auxCurr;
	  nz = (u8*)auxNext;
	  for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++, nz++ ) {
	    *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) < (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}

	/* last slice */
#if 1
	ires = (int*)auxTmp; ip = (int*)auxPrev; ic = (int*)auxCurr;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ & *ip++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	pz = (u8*)auxPrev;   cz = (u8*)auxCurr;
	for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++ )
	    *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    case 10 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxPrev = (void*)localTab[2];
	void *tmp;
	register u8 *px = cur;
	register u8 *cy, *py, *ny;
	register u8 *pz = cur, *nz = cur;
	register u8 *res;

	px -= 1;
	pz -= dxy;   nz += dxy;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (u8*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 1
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u8*)auxCurr;
	py = cy = ny = (u8*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 1
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (u8*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, nz++ )
	  if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	pz += dxy;
	tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;

	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* current slice: 8-connectivity */
	  /* computing along X */
	  res = (u8*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 1
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (u8*)auxCurr;
	  py = cy = ny = (u8*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 1
	    if ( *cy == 0 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* computing along Z */
	  res = (u8*)auxCurr;
	  for ( x = 0; x < dxy; x ++, res++, pz++, nz++ ) {
#if 1
	    if ( *res == 0 ) continue;
#endif
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;
	}

	/* last slice: 8-connectivity */
	/* computing along X */
	res = (u8*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 1
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u8*)auxCurr;
	py = cy = ny = (u8*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 1
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (u8*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, pz++ )
	  if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;

    case 18 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *aux4Prev = (void*)localTab[0];
	void *aux4Curr = (void*)localTab[1];
	void *aux4Next = (void*)localTab[2];
	void *auxCurr = (void*)localTab[3];
	void *auxNext = (void*)localTab[4];
	void *tmp;
	register u8 *px = cur;
	register u8 *ppy = cur, *nny = cur;
	register u8 *cy, *py, *ny;
#if 1
	register int *ic, *in, *ip;
#else
	register u8 *cz, *pz, *nz;
#endif
	register u8 *res;
	
	px -= 1;
	ppy -= dx;   nny += dx;

	/* first slice: computing along X */
	res = (u8*)aux4Curr;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 1
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* first slice: 8-connectivity: computing along Y */
	res = (u8*)auxCurr;
	py = cy = ny = (u8*)aux4Curr;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 1
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* first slice: 4-connectivity: computing along Y */
	res = (u8*)aux4Curr;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 1
	  if ( *res == 0 ) continue;
#endif
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;

	/* second slice: computing along X */
	res = (u8*)aux4Next;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 1
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* second slice: 8-connectivity: computing along Y */
	res = (u8*)auxNext;
	py = cy = ny = (u8*)aux4Next;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 1
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* second slice: 4-connectivity: computing along Y */
	res = (u8*)aux4Next;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 1
	  if ( *res == 0 ) continue;
#endif
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;
	
	/* first slice: result */
#if 1
	ic = (int*)auxCurr; in = (int*)aux4Next;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ &= *in++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
	resBuf += dxy;
#else
	cz = (u8*)auxCurr;   nz = (u8*)aux4Next;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) < (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif
	tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;

	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: computing along X */
	  res = (u8*)aux4Next;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 1
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* next slice: 8-connectivity: computing along Y */
	  res = (u8*)auxNext;
	  py = cy = ny = (u8*)aux4Next;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 1
	    if ( *cy == 0 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* next slice: 4-connectivity: computing along Y */
	  res = (u8*)aux4Next;
	  for ( x = 0; x < dx; x++, res++, nny++ )
	    if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  ppy += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 1
	    if ( *res == 0 ) continue;
#endif
	    if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	    if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  }
	  for ( x = 0; x < dx; x++, res++, ppy++ ) 
	    if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  nny += dx;
	  
	  /* current slice: result */
#if 1
	  ic = (int*)auxCurr; in = (int*)aux4Next; ip = (int*)aux4Prev;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ic++ &= *in++ & *ip++;
	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
#else
	  cz = (u8*)auxCurr;   nz = (u8*)aux4Next;
	  pz = (u8*)aux4Prev;
	  for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++, pz++ ) {
	    *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) < (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	  tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}
	
	/* last slice: result */
#if 1
	ic = (int*)auxCurr; ip = (int*)aux4Prev;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ &= *ip++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
#else
	cz = (u8*)auxCurr;   pz = (u8*)aux4Prev;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, pz++ )
	  *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    }
    input = resultBuf;
  }
  /* end */
  free( (void*)localBuf );
}

/* for binary operations only. With respect to grey-level operations,
   it seems that these operations are a little bit faster (a few percents
   on the CPU time), more experiments have to be conducted.
#define _TWO_OPS_( RES, A, B ) RES = ( ((int)(A)) | ((int)(B)) ) 
#define _ONE_OP_( RES, A )     RES = ( ((int)(RES)) | ((int)(A)) ) 
*/
/* for grey-level operations (works for binary operations too) */
/*
#define _TWO_OPS_( RES, A, B ) RES = ( (A) > (B) ? (A) : (B) )
#define _ONE_OP_( RES, A )     if ( (A) > (RES) ) RES = (A)
*/

/* 
   255
   if the result value is already set to this value
   there is nothing to be done.
   Because it makes the code longer and harder to read
   this test is only performed when at the center of 
   slices. */

/* Morphological operation :

   GreyLevel -> [Binary | GreyLevel ]
           in case of Binary    => 0 == 1
	   in case of GreyLevel => 0 == 0
   Dilation -> [Erosion | Dilation]
           in case of Erosion  => > == '<'
	                          | == '&'
	   in case of Dilation => > == '>'
	                          | == '|'
	   
   4-connectivity: one pointer par neighbor

*/

void GreyLevelDilation_u8 ( void* inputBuf, /* buffer to be resampled */
			  void* resultBuf, /* result buffer */
			  int *theDim, /* dimensions of this buffer */
			  int connectivity, /* connectivity to be used */ 
			  int iterations  /* number of iterations */ )
{
  int conn = 0;                 /* "local" connectivity */
  u8 *localBuf = (void*)NULL; /* buffer for auxiliary computation */
  char *localTab[5];
  void *input;

  int dx, dy, dz, dx1, dy1, dz1;
  int dxy;
  int sliceSize, auxIntSize;
  register int x, y, z;
  int iter;

  if ( iterations <= 0 ) return;


  /* test on connectivity */
  conn = connectivity;
  switch ( conn ) {
  case 4 :
  case 8 :
  case 6 :
  case 10 :
  case 18 :
  case 26 :
    break ;
  default :
    conn = 26;
  }
  
  /* initialization */
  dx = theDim[0];   dx1 = dx - 1;
  dy = theDim[1];   dy1 = dy - 1;
  dz = theDim[2];   dz1 = dz - 1;
  dxy = dx * dy;

  if ( dz == 1 ) {
    switch ( conn ) {
    case 6 :
      conn = 4; break;
    case 10 :
    case 18 :
    case 26 :
      conn = 8; break;
    }
  }

  /* allocation of the auxiliary buffer 
     be sure that the size of each auxiliary slice is 
     a multiple of sizeof(int) for binary computation
   */
  sliceSize = dx * dy * sizeof(u8);
  auxIntSize = 1 + sliceSize / sizeof( int );
  localBuf = (void*)malloc( (unsigned int)(5 * auxIntSize * sizeof(int)) );
  if ( localBuf == (void*)NULL ) return;

  {
    char *t;
    for ( x = 0; x < 5; x ++ ) {
      t = (char*)localBuf;
      t += x * auxIntSize * sizeof( int );
      localTab[x] = (char*)t;
    }
  }

  input =  inputBuf;
  /* iterative processing */
  for ( iter = 0; iter < iterations; iter ++ ) {
    switch ( conn ) {

    /* 4-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 4 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	register u8 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register u8 *res;
	py -= dx;   px -= 1; 
	ny += dx;   nx += 1; 

	for ( z = 0; z < dz; z ++ ) {
	  res = (u8*)auxCurr;
	  /* first row */
	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; ny++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; ny++; res++;
	  py += dx;

	  /* middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 0
	    if ( *cur == 255 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, res++ ) {
#if 0
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    }
#if 0
	    if ( *cur == 255 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	  }

	  /* last row */
	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; py++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; py++; res++;
	  ny += dx;
	  /* copy */

	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
	}
      }
      break;
      
    /* 8-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X- or Y-lines
    */
    case 8 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	register u8 *px = cur;
	register u8 *cy, *py, *ny;
	register u8 *res;

	px -= 1;
	
	for ( z = 0; z < dz; z ++ ) {
	  /* computing along X */
	  res = (u8*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  py = cy = ny = (u8*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, resBuf++, cy++, ny++ )
	    *resBuf = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, resBuf++ ) {
#if 0
	    if ( *cy == 255 ) {
	      *resBuf = *cy;
	      continue;
	    }
#endif
	    *resBuf = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	    if ( (*py) > (*resBuf) ) *resBuf = (*py); /* _ONE_OP_( *resBuf, *py ); */
	  }
	  for ( x = 0; x < dx; x++, resBuf++, cy++, py++ ) 
	    *resBuf = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *resBuf, *cy, *py ); */
	}
      }
      break;
      

    /* 6-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 6 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	void *auxPrev = (void*)localTab[1];
	void *tmp;
	register u8 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register u8 *pz = cur, *nz = cur; 
	register u8 *res;

	pz -= dxy;   py -= dx;   px -= 1; 
	nz += dxy;   ny += dx;   nx += 1; 

	/* first slice */
	res = (u8*)auxCurr;
	/* first slice, first row */
	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, res++ ) {
#if 0
	  if ( *cur == 255 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;
	py += dx;

	/* first slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 0
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
#if 0
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	}

	/* first slice, last row */
	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, res++ ) {
#if 0
	  if ( *cur == 255 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;
	ny += dx; pz += dxy;
	tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	
	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  res = (u8*)auxCurr;
	  /* middle slice, first row */
#if 0
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, pz++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  py += dx;
	  /* middle slice, middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 0
	    if ( *cur == 255 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, pz++, res++ ) {
#if 0
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    }
#if 0
	    if ( *cur == 255 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	  }
	  /* middle slice, last row */
#if 0
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, pz++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  ny += dx;
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	}

	/* last slice */
	res = (u8*)auxCurr;
	/* last slice, first row */
	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, pz++, res++ ) {
#if 0
	  if ( *cur == 255 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;
	py += dx;

	/* last slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 0
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, pz++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	}

	/* last slice, last row */
	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, pz++, res++ ) {
#if 0
	  if ( *cur == 255 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;
      
    /* 26-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X-, Y-lines
    */
    case 26 :
      /* les performances semblent moindres que celles de l'ancienne version
	 (en niveaux de gris), de l'ordre de 2 %
       */
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxNext = (void*)localTab[2];
	void *auxPrev = (void*)localTab[3];
	void *tmp;
	register u8 *px = cur;
	register u8 *cy, *py, *ny;
#if 0
	register int *ires, *ic, *in, *ip;
#else
	register u8 *cz, *pz, *nz;
#endif
	register u8 *res;

	px -= 1;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (u8*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u8*)auxCurr;
	py = cy = ny = (u8*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */

	/* second slice: 8-connectivity */
	/* computing along X */
	res = (u8*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u8*)auxNext;
	py = cy = ny = (u8*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x ++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	
	/* first slice: result 
	   if we cast slices of auxiliary buffer to be divided
	   by sizeof(int) we may use logical operations
	 */
#if 0
	ires = (int*)auxTmp; ic = (int*)auxCurr; in = (int*)auxNext;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ | *in++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	cz = (u8*)auxCurr;   nz = (u8*)auxNext;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) > (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif

	tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	
	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: 8-connectivity */
	  /* computing along X */
	  res = (u8*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (u8*)auxNext;
	  py = cy = ny = (u8*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 255 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  
#if 0
	  ires = (int*)auxTmp; ip = (int*)auxPrev;
	  ic = (int*)auxCurr; in = (int*)auxNext;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ires++ = *ic++ | *in++ | *ip++;
	  memcpy( (void*)resBuf, auxTmp, sliceSize );
	  resBuf += dxy;
#else
	  pz = (u8*)auxPrev;   cz = (u8*)auxCurr;
	  nz = (u8*)auxNext;
	  for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++, nz++ ) {
	    *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) > (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}

	/* last slice */
#if 0
	ires = (int*)auxTmp; ip = (int*)auxPrev; ic = (int*)auxCurr;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ | *ip++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	pz = (u8*)auxPrev;   cz = (u8*)auxCurr;
	for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++ )
	    *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    case 10 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxPrev = (void*)localTab[2];
	void *tmp;
	register u8 *px = cur;
	register u8 *cy, *py, *ny;
	register u8 *pz = cur, *nz = cur;
	register u8 *res;

	px -= 1;
	pz -= dxy;   nz += dxy;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (u8*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u8*)auxCurr;
	py = cy = ny = (u8*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (u8*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, nz++ )
	  if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	pz += dxy;
	tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;

	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* current slice: 8-connectivity */
	  /* computing along X */
	  res = (u8*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (u8*)auxCurr;
	  py = cy = ny = (u8*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 255 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* computing along Z */
	  res = (u8*)auxCurr;
	  for ( x = 0; x < dxy; x ++, res++, pz++, nz++ ) {
#if 0
	    if ( *res == 255 ) continue;
#endif
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;
	}

	/* last slice: 8-connectivity */
	/* computing along X */
	res = (u8*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u8*)auxCurr;
	py = cy = ny = (u8*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (u8*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, pz++ )
	  if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;

    case 18 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *aux4Prev = (void*)localTab[0];
	void *aux4Curr = (void*)localTab[1];
	void *aux4Next = (void*)localTab[2];
	void *auxCurr = (void*)localTab[3];
	void *auxNext = (void*)localTab[4];
	void *tmp;
	register u8 *px = cur;
	register u8 *ppy = cur, *nny = cur;
	register u8 *cy, *py, *ny;
#if 0
	register int *ic, *in, *ip;
#else
	register u8 *cz, *pz, *nz;
#endif
	register u8 *res;
	
	px -= 1;
	ppy -= dx;   nny += dx;

	/* first slice: computing along X */
	res = (u8*)aux4Curr;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* first slice: 8-connectivity: computing along Y */
	res = (u8*)auxCurr;
	py = cy = ny = (u8*)aux4Curr;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* first slice: 4-connectivity: computing along Y */
	res = (u8*)aux4Curr;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	  if ( *res == 255 ) continue;
#endif
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;

	/* second slice: computing along X */
	res = (u8*)aux4Next;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* second slice: 8-connectivity: computing along Y */
	res = (u8*)auxNext;
	py = cy = ny = (u8*)aux4Next;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* second slice: 4-connectivity: computing along Y */
	res = (u8*)aux4Next;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	  if ( *res == 255 ) continue;
#endif
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;
	
	/* first slice: result */
#if 0
	ic = (int*)auxCurr; in = (int*)aux4Next;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ |= *in++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
	resBuf += dxy;
#else
	cz = (u8*)auxCurr;   nz = (u8*)aux4Next;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) > (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif
	tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;

	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: computing along X */
	  res = (u8*)aux4Next;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* next slice: 8-connectivity: computing along Y */
	  res = (u8*)auxNext;
	  py = cy = ny = (u8*)aux4Next;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 255 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* next slice: 4-connectivity: computing along Y */
	  res = (u8*)aux4Next;
	  for ( x = 0; x < dx; x++, res++, nny++ )
	    if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  ppy += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	    if ( *res == 255 ) continue;
#endif
	    if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	    if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  }
	  for ( x = 0; x < dx; x++, res++, ppy++ ) 
	    if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  nny += dx;
	  
	  /* current slice: result */
#if 0
	  ic = (int*)auxCurr; in = (int*)aux4Next; ip = (int*)aux4Prev;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ic++ |= *in++ | *ip++;
	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
#else
	  cz = (u8*)auxCurr;   nz = (u8*)aux4Next;
	  pz = (u8*)aux4Prev;
	  for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++, pz++ ) {
	    *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) > (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	  tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}
	
	/* last slice: result */
#if 0
	ic = (int*)auxCurr; ip = (int*)aux4Prev;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ |= *ip++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
#else
	cz = (u8*)auxCurr;   pz = (u8*)aux4Prev;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, pz++ )
	  *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    }
    input = resultBuf;
  }
  /* end */
  free( (void*)localBuf );
}

/* for binary operations only. With respect to grey-level operations,
   it seems that these operations are a little bit faster (a few percents
   on the CPU time), more experiments have to be conducted.
#define _TWO_OPS_( RES, A, B ) RES = ( ((int)(A)) | ((int)(B)) ) 
#define _ONE_OP_( RES, A )     RES = ( ((int)(RES)) | ((int)(A)) ) 
*/
/* for grey-level operations (works for binary operations too) */
/*
#define _TWO_OPS_( RES, A, B ) RES = ( (A) < (B) ? (A) : (B) )
#define _ONE_OP_( RES, A )     if ( (A) < (RES) ) RES = (A)
*/

/* 
   0
   if the result value is already set to this value
   there is nothing to be done.
   Because it makes the code longer and harder to read
   this test is only performed when at the center of 
   slices. */

/* Morphological operation :

   GreyLevel -> [Binary | GreyLevel ]
           in case of Binary    => 0 == 1
	   in case of GreyLevel => 0 == 0
   Erosion -> [Erosion | Dilation]
           in case of Erosion  => < == '<'
	                          & == '&'
	   in case of Dilation => < == '>'
	                          & == '|'
	   
   4-connectivity: one pointer par neighbor

*/

void GreyLevelErosion_u8 ( void* inputBuf, /* buffer to be resampled */
			  void* resultBuf, /* result buffer */
			  int *theDim, /* dimensions of this buffer */
			  int connectivity, /* connectivity to be used */ 
			  int iterations  /* number of iterations */ )
{
  int conn = 0;                 /* "local" connectivity */
  u8 *localBuf = (void*)NULL; /* buffer for auxiliary computation */
  char *localTab[5];
  void *input;

  int dx, dy, dz, dx1, dy1, dz1;
  int dxy;
  int sliceSize, auxIntSize;
  register int x, y, z;
  int iter;

  if ( iterations <= 0 ) return;


  /* test on connectivity */
  conn = connectivity;
  switch ( conn ) {
  case 4 :
  case 8 :
  case 6 :
  case 10 :
  case 18 :
  case 26 :
    break ;
  default :
    conn = 26;
  }
  
  /* initialization */
  dx = theDim[0];   dx1 = dx - 1;
  dy = theDim[1];   dy1 = dy - 1;
  dz = theDim[2];   dz1 = dz - 1;
  dxy = dx * dy;

  if ( dz == 1 ) {
    switch ( conn ) {
    case 6 :
      conn = 4; break;
    case 10 :
    case 18 :
    case 26 :
      conn = 8; break;
    }
  }

  /* allocation of the auxiliary buffer 
     be sure that the size of each auxiliary slice is 
     a multiple of sizeof(int) for binary computation
   */
  sliceSize = dx * dy * sizeof(u8);
  auxIntSize = 1 + sliceSize / sizeof( int );
  localBuf = (void*)malloc( (unsigned int)(5 * auxIntSize * sizeof(int)) );
  if ( localBuf == (void*)NULL ) return;

  {
    char *t;
    for ( x = 0; x < 5; x ++ ) {
      t = (char*)localBuf;
      t += x * auxIntSize * sizeof( int );
      localTab[x] = (char*)t;
    }
  }

  input =  inputBuf;
  /* iterative processing */
  for ( iter = 0; iter < iterations; iter ++ ) {
    switch ( conn ) {

    /* 4-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 4 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	register u8 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register u8 *res;
	py -= dx;   px -= 1; 
	ny += dx;   nx += 1; 

	for ( z = 0; z < dz; z ++ ) {
	  res = (u8*)auxCurr;
	  /* first row */
	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; ny++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; ny++; res++;
	  py += dx;

	  /* middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 0
	    if ( *cur == 0 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    }
#if 0
	    if ( *cur == 0 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	  }

	  /* last row */
	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; py++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; py++; res++;
	  ny += dx;
	  /* copy */

	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
	}
      }
      break;
      
    /* 8-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X- or Y-lines
    */
    case 8 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	register u8 *px = cur;
	register u8 *cy, *py, *ny;
	register u8 *res;

	px -= 1;
	
	for ( z = 0; z < dz; z ++ ) {
	  /* computing along X */
	  res = (u8*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  py = cy = ny = (u8*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, resBuf++, cy++, ny++ )
	    *resBuf = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, resBuf++ ) {
#if 0
	    if ( *cy == 0 ) {
	      *resBuf = *cy;
	      continue;
	    }
#endif
	    *resBuf = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	    if ( (*py) < (*resBuf) ) *resBuf = (*py); /* _ONE_OP_( *resBuf, *py ); */
	  }
	  for ( x = 0; x < dx; x++, resBuf++, cy++, py++ ) 
	    *resBuf = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *resBuf, *cy, *py ); */
	}
      }
      break;
      

    /* 6-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 6 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	void *auxPrev = (void*)localTab[1];
	void *tmp;
	register u8 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register u8 *pz = cur, *nz = cur; 
	register u8 *res;

	pz -= dxy;   py -= dx;   px -= 1; 
	nz += dxy;   ny += dx;   nx += 1; 

	/* first slice */
	res = (u8*)auxCurr;
	/* first slice, first row */
	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, res++ ) {
#if 0
	  if ( *cur == 0 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;
	py += dx;

	/* first slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	}

	/* first slice, last row */
	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, res++ ) {
#if 0
	  if ( *cur == 0 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;
	ny += dx; pz += dxy;
	tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	
	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  res = (u8*)auxCurr;
	  /* middle slice, first row */
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, pz++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  py += dx;
	  /* middle slice, middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 0
	    if ( *cur == 0 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, pz++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    }
#if 0
	    if ( *cur == 0 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	  }
	  /* middle slice, last row */
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, pz++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  ny += dx;
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	}

	/* last slice */
	res = (u8*)auxCurr;
	/* last slice, first row */
	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, pz++, res++ ) {
#if 0
	  if ( *cur == 0 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;
	py += dx;

	/* last slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, pz++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	}

	/* last slice, last row */
	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, pz++, res++ ) {
#if 0
	  if ( *cur == 0 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;
      
    /* 26-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X-, Y-lines
    */
    case 26 :
      /* les performances semblent moindres que celles de l'ancienne version
	 (en niveaux de gris), de l'ordre de 2 %
       */
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxNext = (void*)localTab[2];
	void *auxPrev = (void*)localTab[3];
	void *tmp;
	register u8 *px = cur;
	register u8 *cy, *py, *ny;
#if 0
	register int *ires, *ic, *in, *ip;
#else
	register u8 *cz, *pz, *nz;
#endif
	register u8 *res;

	px -= 1;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (u8*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u8*)auxCurr;
	py = cy = ny = (u8*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */

	/* second slice: 8-connectivity */
	/* computing along X */
	res = (u8*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u8*)auxNext;
	py = cy = ny = (u8*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x ++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	
	/* first slice: result 
	   if we cast slices of auxiliary buffer to be divided
	   by sizeof(int) we may use logical operations
	 */
#if 0
	ires = (int*)auxTmp; ic = (int*)auxCurr; in = (int*)auxNext;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ & *in++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	cz = (u8*)auxCurr;   nz = (u8*)auxNext;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) < (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif

	tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	
	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: 8-connectivity */
	  /* computing along X */
	  res = (u8*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (u8*)auxNext;
	  py = cy = ny = (u8*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 0 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  
#if 0
	  ires = (int*)auxTmp; ip = (int*)auxPrev;
	  ic = (int*)auxCurr; in = (int*)auxNext;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ires++ = *ic++ & *in++ & *ip++;
	  memcpy( (void*)resBuf, auxTmp, sliceSize );
	  resBuf += dxy;
#else
	  pz = (u8*)auxPrev;   cz = (u8*)auxCurr;
	  nz = (u8*)auxNext;
	  for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++, nz++ ) {
	    *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) < (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}

	/* last slice */
#if 0
	ires = (int*)auxTmp; ip = (int*)auxPrev; ic = (int*)auxCurr;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ & *ip++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	pz = (u8*)auxPrev;   cz = (u8*)auxCurr;
	for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++ )
	    *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    case 10 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxPrev = (void*)localTab[2];
	void *tmp;
	register u8 *px = cur;
	register u8 *cy, *py, *ny;
	register u8 *pz = cur, *nz = cur;
	register u8 *res;

	px -= 1;
	pz -= dxy;   nz += dxy;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (u8*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u8*)auxCurr;
	py = cy = ny = (u8*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (u8*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, nz++ )
	  if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	pz += dxy;
	tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;

	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* current slice: 8-connectivity */
	  /* computing along X */
	  res = (u8*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (u8*)auxCurr;
	  py = cy = ny = (u8*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 0 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* computing along Z */
	  res = (u8*)auxCurr;
	  for ( x = 0; x < dxy; x ++, res++, pz++, nz++ ) {
#if 0
	    if ( *res == 0 ) continue;
#endif
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;
	}

	/* last slice: 8-connectivity */
	/* computing along X */
	res = (u8*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u8*)auxCurr;
	py = cy = ny = (u8*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (u8*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, pz++ )
	  if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;

    case 18 :
      {
	register u8 *cur = (u8*)(input);
	u8 *resBuf = (u8*)(resultBuf);
	void *aux4Prev = (void*)localTab[0];
	void *aux4Curr = (void*)localTab[1];
	void *aux4Next = (void*)localTab[2];
	void *auxCurr = (void*)localTab[3];
	void *auxNext = (void*)localTab[4];
	void *tmp;
	register u8 *px = cur;
	register u8 *ppy = cur, *nny = cur;
	register u8 *cy, *py, *ny;
#if 0
	register int *ic, *in, *ip;
#else
	register u8 *cz, *pz, *nz;
#endif
	register u8 *res;
	
	px -= 1;
	ppy -= dx;   nny += dx;

	/* first slice: computing along X */
	res = (u8*)aux4Curr;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* first slice: 8-connectivity: computing along Y */
	res = (u8*)auxCurr;
	py = cy = ny = (u8*)aux4Curr;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* first slice: 4-connectivity: computing along Y */
	res = (u8*)aux4Curr;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	  if ( *res == 0 ) continue;
#endif
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;

	/* second slice: computing along X */
	res = (u8*)aux4Next;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* second slice: 8-connectivity: computing along Y */
	res = (u8*)auxNext;
	py = cy = ny = (u8*)aux4Next;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* second slice: 4-connectivity: computing along Y */
	res = (u8*)aux4Next;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	  if ( *res == 0 ) continue;
#endif
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;
	
	/* first slice: result */
#if 0
	ic = (int*)auxCurr; in = (int*)aux4Next;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ &= *in++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
	resBuf += dxy;
#else
	cz = (u8*)auxCurr;   nz = (u8*)aux4Next;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) < (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif
	tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;

	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: computing along X */
	  res = (u8*)aux4Next;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* next slice: 8-connectivity: computing along Y */
	  res = (u8*)auxNext;
	  py = cy = ny = (u8*)aux4Next;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 0 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* next slice: 4-connectivity: computing along Y */
	  res = (u8*)aux4Next;
	  for ( x = 0; x < dx; x++, res++, nny++ )
	    if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  ppy += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	    if ( *res == 0 ) continue;
#endif
	    if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	    if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  }
	  for ( x = 0; x < dx; x++, res++, ppy++ ) 
	    if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  nny += dx;
	  
	  /* current slice: result */
#if 0
	  ic = (int*)auxCurr; in = (int*)aux4Next; ip = (int*)aux4Prev;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ic++ &= *in++ & *ip++;
	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
#else
	  cz = (u8*)auxCurr;   nz = (u8*)aux4Next;
	  pz = (u8*)aux4Prev;
	  for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++, pz++ ) {
	    *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) < (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	  tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}
	
	/* last slice: result */
#if 0
	ic = (int*)auxCurr; ip = (int*)aux4Prev;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ &= *ip++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
#else
	cz = (u8*)auxCurr;   pz = (u8*)aux4Prev;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, pz++ )
	  *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    }
    input = resultBuf;
  }
  /* end */
  free( (void*)localBuf );
}

/* for binary operations only. With respect to grey-level operations,
   it seems that these operations are a little bit faster (a few percents
   on the CPU time), more experiments have to be conducted.
#define _TWO_OPS_( RES, A, B ) RES = ( ((int)(A)) | ((int)(B)) ) 
#define _ONE_OP_( RES, A )     RES = ( ((int)(RES)) | ((int)(A)) ) 
*/
/* for grey-level operations (works for binary operations too) */
/*
#define _TWO_OPS_( RES, A, B ) RES = ( (A) > (B) ? (A) : (B) )
#define _ONE_OP_( RES, A )     if ( (A) > (RES) ) RES = (A)
*/

/* 
   255
   if the result value is already set to this value
   there is nothing to be done.
   Because it makes the code longer and harder to read
   this test is only performed when at the center of 
   slices. */

/* Morphological operation :

   GreyLevel -> [Binary | GreyLevel ]
           in case of Binary    => 0 == 1
	   in case of GreyLevel => 0 == 0
   Dilation -> [Erosion | Dilation]
           in case of Erosion  => > == '<'
	                          | == '&'
	   in case of Dilation => > == '>'
	                          | == '|'
	   
   4-connectivity: one pointer par neighbor

*/

void GreyLevelDilation_r32 ( void* inputBuf, /* buffer to be resampled */
			  void* resultBuf, /* result buffer */
			  int *theDim, /* dimensions of this buffer */
			  int connectivity, /* connectivity to be used */ 
			  int iterations  /* number of iterations */ )
{
  int conn = 0;                 /* "local" connectivity */
  r32 *localBuf = (void*)NULL; /* buffer for auxiliary computation */
  char *localTab[5];
  void *input;

  int dx, dy, dz, dx1, dy1, dz1;
  int dxy;
  int sliceSize, auxIntSize;
  register int x, y, z;
  int iter;

  if ( iterations <= 0 ) return;


  /* test on connectivity */
  conn = connectivity;
  switch ( conn ) {
  case 4 :
  case 8 :
  case 6 :
  case 10 :
  case 18 :
  case 26 :
    break ;
  default :
    conn = 26;
  }
  
  /* initialization */
  dx = theDim[0];   dx1 = dx - 1;
  dy = theDim[1];   dy1 = dy - 1;
  dz = theDim[2];   dz1 = dz - 1;
  dxy = dx * dy;

  if ( dz == 1 ) {
    switch ( conn ) {
    case 6 :
      conn = 4; break;
    case 10 :
    case 18 :
    case 26 :
      conn = 8; break;
    }
  }

  /* allocation of the auxiliary buffer 
     be sure that the size of each auxiliary slice is 
     a multiple of sizeof(int) for binary computation
   */
  sliceSize = dx * dy * sizeof(r32);
  auxIntSize = 1 + sliceSize / sizeof( int );
  localBuf = (void*)malloc( (unsigned int)(5 * auxIntSize * sizeof(int)) );
  if ( localBuf == (void*)NULL ) return;

  {
    char *t;
    for ( x = 0; x < 5; x ++ ) {
      t = (char*)localBuf;
      t += x * auxIntSize * sizeof( int );
      localTab[x] = (char*)t;
    }
  }

  input =  inputBuf;
  /* iterative processing */
  for ( iter = 0; iter < iterations; iter ++ ) {
    switch ( conn ) {

    /* 4-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 4 :
      {
	register r32 *cur = (r32*)(input);
	r32 *resBuf = (r32*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	register r32 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register r32 *res;
	py -= dx;   px -= 1; 
	ny += dx;   nx += 1; 

	for ( z = 0; z < dz; z ++ ) {
	  res = (r32*)auxCurr;
	  /* first row */
	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; ny++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; ny++; res++;
	  py += dx;

	  /* middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 0
	    if ( *cur == 255 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, res++ ) {
#if 0
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    }
#if 0
	    if ( *cur == 255 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	  }

	  /* last row */
	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; py++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; py++; res++;
	  ny += dx;
	  /* copy */

	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
	}
      }
      break;
      
    /* 8-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X- or Y-lines
    */
    case 8 :
      {
	register r32 *cur = (r32*)(input);
	r32 *resBuf = (r32*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	register r32 *px = cur;
	register r32 *cy, *py, *ny;
	register r32 *res;

	px -= 1;
	
	for ( z = 0; z < dz; z ++ ) {
	  /* computing along X */
	  res = (r32*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  py = cy = ny = (r32*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, resBuf++, cy++, ny++ )
	    *resBuf = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, resBuf++ ) {
#if 0
	    if ( *cy == 255 ) {
	      *resBuf = *cy;
	      continue;
	    }
#endif
	    *resBuf = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	    if ( (*py) > (*resBuf) ) *resBuf = (*py); /* _ONE_OP_( *resBuf, *py ); */
	  }
	  for ( x = 0; x < dx; x++, resBuf++, cy++, py++ ) 
	    *resBuf = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *resBuf, *cy, *py ); */
	}
      }
      break;
      

    /* 6-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 6 :
      {
	register r32 *cur = (r32*)(input);
	r32 *resBuf = (r32*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	void *auxPrev = (void*)localTab[1];
	void *tmp;
	register r32 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register r32 *pz = cur, *nz = cur; 
	register r32 *res;

	pz -= dxy;   py -= dx;   px -= 1; 
	nz += dxy;   ny += dx;   nx += 1; 

	/* first slice */
	res = (r32*)auxCurr;
	/* first slice, first row */
	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, res++ ) {
#if 0
	  if ( *cur == 255 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;
	py += dx;

	/* first slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 0
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
#if 0
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	}

	/* first slice, last row */
	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, res++ ) {
#if 0
	  if ( *cur == 255 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;
	ny += dx; pz += dxy;
	tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	
	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  res = (r32*)auxCurr;
	  /* middle slice, first row */
#if 0
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, pz++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  py += dx;
	  /* middle slice, middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 0
	    if ( *cur == 255 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, pz++, res++ ) {
#if 0
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    }
#if 0
	    if ( *cur == 255 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	  }
	  /* middle slice, last row */
#if 0
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, pz++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  ny += dx;
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	}

	/* last slice */
	res = (r32*)auxCurr;
	/* last slice, first row */
	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, pz++, res++ ) {
#if 0
	  if ( *cur == 255 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;
	py += dx;

	/* last slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 0
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, pz++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 255 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	}

	/* last slice, last row */
	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, pz++, res++ ) {
#if 0
	  if ( *cur == 255 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;
      
    /* 26-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X-, Y-lines
    */
    case 26 :
      /* les performances semblent moindres que celles de l'ancienne version
	 (en niveaux de gris), de l'ordre de 2 %
       */
      {
	register r32 *cur = (r32*)(input);
	r32 *resBuf = (r32*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxNext = (void*)localTab[2];
	void *auxPrev = (void*)localTab[3];
	void *tmp;
	register r32 *px = cur;
	register r32 *cy, *py, *ny;
#if 0
	register int *ires, *ic, *in, *ip;
#else
	register r32 *cz, *pz, *nz;
#endif
	register r32 *res;

	px -= 1;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (r32*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (r32*)auxCurr;
	py = cy = ny = (r32*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */

	/* second slice: 8-connectivity */
	/* computing along X */
	res = (r32*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (r32*)auxNext;
	py = cy = ny = (r32*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x ++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	
	/* first slice: result 
	   if we cast slices of auxiliary buffer to be divided
	   by sizeof(int) we may use logical operations
	 */
#if 0
	ires = (int*)auxTmp; ic = (int*)auxCurr; in = (int*)auxNext;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ | *in++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	cz = (r32*)auxCurr;   nz = (r32*)auxNext;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) > (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif

	tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	
	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: 8-connectivity */
	  /* computing along X */
	  res = (r32*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (r32*)auxNext;
	  py = cy = ny = (r32*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 255 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  
#if 0
	  ires = (int*)auxTmp; ip = (int*)auxPrev;
	  ic = (int*)auxCurr; in = (int*)auxNext;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ires++ = *ic++ | *in++ | *ip++;
	  memcpy( (void*)resBuf, auxTmp, sliceSize );
	  resBuf += dxy;
#else
	  pz = (r32*)auxPrev;   cz = (r32*)auxCurr;
	  nz = (r32*)auxNext;
	  for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++, nz++ ) {
	    *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) > (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}

	/* last slice */
#if 0
	ires = (int*)auxTmp; ip = (int*)auxPrev; ic = (int*)auxCurr;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ | *ip++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	pz = (r32*)auxPrev;   cz = (r32*)auxCurr;
	for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++ )
	    *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    case 10 :
      {
	register r32 *cur = (r32*)(input);
	r32 *resBuf = (r32*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxPrev = (void*)localTab[2];
	void *tmp;
	register r32 *px = cur;
	register r32 *cy, *py, *ny;
	register r32 *pz = cur, *nz = cur;
	register r32 *res;

	px -= 1;
	pz -= dxy;   nz += dxy;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (r32*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (r32*)auxCurr;
	py = cy = ny = (r32*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (r32*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, nz++ )
	  if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	pz += dxy;
	tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;

	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* current slice: 8-connectivity */
	  /* computing along X */
	  res = (r32*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (r32*)auxCurr;
	  py = cy = ny = (r32*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 255 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* computing along Z */
	  res = (r32*)auxCurr;
	  for ( x = 0; x < dxy; x ++, res++, pz++, nz++ ) {
#if 0
	    if ( *res == 255 ) continue;
#endif
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;
	}

	/* last slice: 8-connectivity */
	/* computing along X */
	res = (r32*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (r32*)auxCurr;
	py = cy = ny = (r32*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (r32*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, pz++ )
	  if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;

    case 18 :
      {
	register r32 *cur = (r32*)(input);
	r32 *resBuf = (r32*)(resultBuf);
	void *aux4Prev = (void*)localTab[0];
	void *aux4Curr = (void*)localTab[1];
	void *aux4Next = (void*)localTab[2];
	void *auxCurr = (void*)localTab[3];
	void *auxNext = (void*)localTab[4];
	void *tmp;
	register r32 *px = cur;
	register r32 *ppy = cur, *nny = cur;
	register r32 *cy, *py, *ny;
#if 0
	register int *ic, *in, *ip;
#else
	register r32 *cz, *pz, *nz;
#endif
	register r32 *res;
	
	px -= 1;
	ppy -= dx;   nny += dx;

	/* first slice: computing along X */
	res = (r32*)aux4Curr;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* first slice: 8-connectivity: computing along Y */
	res = (r32*)auxCurr;
	py = cy = ny = (r32*)aux4Curr;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* first slice: 4-connectivity: computing along Y */
	res = (r32*)aux4Curr;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	  if ( *res == 255 ) continue;
#endif
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;

	/* second slice: computing along X */
	res = (r32*)aux4Next;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 255 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* second slice: 8-connectivity: computing along Y */
	res = (r32*)auxNext;
	py = cy = ny = (r32*)aux4Next;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 255 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* second slice: 4-connectivity: computing along Y */
	res = (r32*)aux4Next;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	  if ( *res == 255 ) continue;
#endif
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;
	
	/* first slice: result */
#if 0
	ic = (int*)auxCurr; in = (int*)aux4Next;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ |= *in++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
	resBuf += dxy;
#else
	cz = (r32*)auxCurr;   nz = (r32*)aux4Next;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) > (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif
	tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;

	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: computing along X */
	  res = (r32*)aux4Next;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 255 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* next slice: 8-connectivity: computing along Y */
	  res = (r32*)auxNext;
	  py = cy = ny = (r32*)aux4Next;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 255 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* next slice: 4-connectivity: computing along Y */
	  res = (r32*)aux4Next;
	  for ( x = 0; x < dx; x++, res++, nny++ )
	    if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  ppy += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	    if ( *res == 255 ) continue;
#endif
	    if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	    if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  }
	  for ( x = 0; x < dx; x++, res++, ppy++ ) 
	    if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  nny += dx;
	  
	  /* current slice: result */
#if 0
	  ic = (int*)auxCurr; in = (int*)aux4Next; ip = (int*)aux4Prev;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ic++ |= *in++ | *ip++;
	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
#else
	  cz = (r32*)auxCurr;   nz = (r32*)aux4Next;
	  pz = (r32*)aux4Prev;
	  for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++, pz++ ) {
	    *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) > (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	  tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}
	
	/* last slice: result */
#if 0
	ic = (int*)auxCurr; ip = (int*)aux4Prev;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ |= *ip++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
#else
	cz = (r32*)auxCurr;   pz = (r32*)aux4Prev;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, pz++ )
	  *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    }
    input = resultBuf;
  }
  /* end */
  free( (void*)localBuf );
}

/* for binary operations only. With respect to grey-level operations,
   it seems that these operations are a little bit faster (a few percents
   on the CPU time), more experiments have to be conducted.
#define _TWO_OPS_( RES, A, B ) RES = ( ((int)(A)) | ((int)(B)) ) 
#define _ONE_OP_( RES, A )     RES = ( ((int)(RES)) | ((int)(A)) ) 
*/
/* for grey-level operations (works for binary operations too) */
/*
#define _TWO_OPS_( RES, A, B ) RES = ( (A) < (B) ? (A) : (B) )
#define _ONE_OP_( RES, A )     if ( (A) < (RES) ) RES = (A)
*/

/* 
   0
   if the result value is already set to this value
   there is nothing to be done.
   Because it makes the code longer and harder to read
   this test is only performed when at the center of 
   slices. */

/* Morphological operation :

   GreyLevel -> [Binary | GreyLevel ]
           in case of Binary    => 0 == 1
	   in case of GreyLevel => 0 == 0
   Erosion -> [Erosion | Dilation]
           in case of Erosion  => < == '<'
	                          & == '&'
	   in case of Dilation => < == '>'
	                          & == '|'
	   
   4-connectivity: one pointer par neighbor

*/

void GreyLevelErosion_r32 ( void* inputBuf, /* buffer to be resampled */
			  void* resultBuf, /* result buffer */
			  int *theDim, /* dimensions of this buffer */
			  int connectivity, /* connectivity to be used */ 
			  int iterations  /* number of iterations */ )
{
  int conn = 0;                 /* "local" connectivity */
  r32 *localBuf = (void*)NULL; /* buffer for auxiliary computation */
  char *localTab[5];
  void *input;

  int dx, dy, dz, dx1, dy1, dz1;
  int dxy;
  int sliceSize, auxIntSize;
  register int x, y, z;
  int iter;

  if ( iterations <= 0 ) return;


  /* test on connectivity */
  conn = connectivity;
  switch ( conn ) {
  case 4 :
  case 8 :
  case 6 :
  case 10 :
  case 18 :
  case 26 :
    break ;
  default :
    conn = 26;
  }
  
  /* initialization */
  dx = theDim[0];   dx1 = dx - 1;
  dy = theDim[1];   dy1 = dy - 1;
  dz = theDim[2];   dz1 = dz - 1;
  dxy = dx * dy;

  if ( dz == 1 ) {
    switch ( conn ) {
    case 6 :
      conn = 4; break;
    case 10 :
    case 18 :
    case 26 :
      conn = 8; break;
    }
  }

  /* allocation of the auxiliary buffer 
     be sure that the size of each auxiliary slice is 
     a multiple of sizeof(int) for binary computation
   */
  sliceSize = dx * dy * sizeof(r32);
  auxIntSize = 1 + sliceSize / sizeof( int );
  localBuf = (void*)malloc( (unsigned int)(5 * auxIntSize * sizeof(int)) );
  if ( localBuf == (void*)NULL ) return;

  {
    char *t;
    for ( x = 0; x < 5; x ++ ) {
      t = (char*)localBuf;
      t += x * auxIntSize * sizeof( int );
      localTab[x] = (char*)t;
    }
  }

  input =  inputBuf;
  /* iterative processing */
  for ( iter = 0; iter < iterations; iter ++ ) {
    switch ( conn ) {

    /* 4-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 4 :
      {
	register r32 *cur = (r32*)(input);
	r32 *resBuf = (r32*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	register r32 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register r32 *res;
	py -= dx;   px -= 1; 
	ny += dx;   nx += 1; 

	for ( z = 0; z < dz; z ++ ) {
	  res = (r32*)auxCurr;
	  /* first row */
	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; ny++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; ny++; res++;
	  py += dx;

	  /* middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 0
	    if ( *cur == 0 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    }
#if 0
	    if ( *cur == 0 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	  }

	  /* last row */
	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; py++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; py++; res++;
	  ny += dx;
	  /* copy */

	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
	}
      }
      break;
      
    /* 8-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X- or Y-lines
    */
    case 8 :
      {
	register r32 *cur = (r32*)(input);
	r32 *resBuf = (r32*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	register r32 *px = cur;
	register r32 *cy, *py, *ny;
	register r32 *res;

	px -= 1;
	
	for ( z = 0; z < dz; z ++ ) {
	  /* computing along X */
	  res = (r32*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  py = cy = ny = (r32*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, resBuf++, cy++, ny++ )
	    *resBuf = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, resBuf++ ) {
#if 0
	    if ( *cy == 0 ) {
	      *resBuf = *cy;
	      continue;
	    }
#endif
	    *resBuf = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	    if ( (*py) < (*resBuf) ) *resBuf = (*py); /* _ONE_OP_( *resBuf, *py ); */
	  }
	  for ( x = 0; x < dx; x++, resBuf++, cy++, py++ ) 
	    *resBuf = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *resBuf, *cy, *py ); */
	}
      }
      break;
      

    /* 6-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 6 :
      {
	register r32 *cur = (r32*)(input);
	r32 *resBuf = (r32*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	void *auxPrev = (void*)localTab[1];
	void *tmp;
	register r32 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register r32 *pz = cur, *nz = cur; 
	register r32 *res;

	pz -= dxy;   py -= dx;   px -= 1; 
	nz += dxy;   ny += dx;   nx += 1; 

	/* first slice */
	res = (r32*)auxCurr;
	/* first slice, first row */
	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, res++ ) {
#if 0
	  if ( *cur == 0 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;
	py += dx;

	/* first slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	}

	/* first slice, last row */
	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, res++ ) {
#if 0
	  if ( *cur == 0 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;
	ny += dx; pz += dxy;
	tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	
	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  res = (r32*)auxCurr;
	  /* middle slice, first row */
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, pz++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  py += dx;
	  /* middle slice, middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 0
	    if ( *cur == 0 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, pz++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    }
#if 0
	    if ( *cur == 0 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	  }
	  /* middle slice, last row */
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, pz++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  ny += dx;
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	}

	/* last slice */
	res = (r32*)auxCurr;
	/* last slice, first row */
	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, pz++, res++ ) {
#if 0
	  if ( *cur == 0 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;
	py += dx;

	/* last slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, pz++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	}

	/* last slice, last row */
	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, pz++, res++ ) {
#if 0
	  if ( *cur == 0 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;
      
    /* 26-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X-, Y-lines
    */
    case 26 :
      /* les performances semblent moindres que celles de l'ancienne version
	 (en niveaux de gris), de l'ordre de 2 %
       */
      {
	register r32 *cur = (r32*)(input);
	r32 *resBuf = (r32*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxNext = (void*)localTab[2];
	void *auxPrev = (void*)localTab[3];
	void *tmp;
	register r32 *px = cur;
	register r32 *cy, *py, *ny;
#if 0
	register int *ires, *ic, *in, *ip;
#else
	register r32 *cz, *pz, *nz;
#endif
	register r32 *res;

	px -= 1;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (r32*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (r32*)auxCurr;
	py = cy = ny = (r32*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */

	/* second slice: 8-connectivity */
	/* computing along X */
	res = (r32*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (r32*)auxNext;
	py = cy = ny = (r32*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x ++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	
	/* first slice: result 
	   if we cast slices of auxiliary buffer to be divided
	   by sizeof(int) we may use logical operations
	 */
#if 0
	ires = (int*)auxTmp; ic = (int*)auxCurr; in = (int*)auxNext;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ & *in++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	cz = (r32*)auxCurr;   nz = (r32*)auxNext;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) < (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif

	tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	
	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: 8-connectivity */
	  /* computing along X */
	  res = (r32*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (r32*)auxNext;
	  py = cy = ny = (r32*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 0 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  
#if 0
	  ires = (int*)auxTmp; ip = (int*)auxPrev;
	  ic = (int*)auxCurr; in = (int*)auxNext;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ires++ = *ic++ & *in++ & *ip++;
	  memcpy( (void*)resBuf, auxTmp, sliceSize );
	  resBuf += dxy;
#else
	  pz = (r32*)auxPrev;   cz = (r32*)auxCurr;
	  nz = (r32*)auxNext;
	  for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++, nz++ ) {
	    *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) < (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}

	/* last slice */
#if 0
	ires = (int*)auxTmp; ip = (int*)auxPrev; ic = (int*)auxCurr;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ & *ip++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	pz = (r32*)auxPrev;   cz = (r32*)auxCurr;
	for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++ )
	    *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    case 10 :
      {
	register r32 *cur = (r32*)(input);
	r32 *resBuf = (r32*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxPrev = (void*)localTab[2];
	void *tmp;
	register r32 *px = cur;
	register r32 *cy, *py, *ny;
	register r32 *pz = cur, *nz = cur;
	register r32 *res;

	px -= 1;
	pz -= dxy;   nz += dxy;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (r32*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (r32*)auxCurr;
	py = cy = ny = (r32*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (r32*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, nz++ )
	  if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	pz += dxy;
	tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;

	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* current slice: 8-connectivity */
	  /* computing along X */
	  res = (r32*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (r32*)auxCurr;
	  py = cy = ny = (r32*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 0 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* computing along Z */
	  res = (r32*)auxCurr;
	  for ( x = 0; x < dxy; x ++, res++, pz++, nz++ ) {
#if 0
	    if ( *res == 0 ) continue;
#endif
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;
	}

	/* last slice: 8-connectivity */
	/* computing along X */
	res = (r32*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (r32*)auxCurr;
	py = cy = ny = (r32*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (r32*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, pz++ )
	  if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;

    case 18 :
      {
	register r32 *cur = (r32*)(input);
	r32 *resBuf = (r32*)(resultBuf);
	void *aux4Prev = (void*)localTab[0];
	void *aux4Curr = (void*)localTab[1];
	void *aux4Next = (void*)localTab[2];
	void *auxCurr = (void*)localTab[3];
	void *auxNext = (void*)localTab[4];
	void *tmp;
	register r32 *px = cur;
	register r32 *ppy = cur, *nny = cur;
	register r32 *cy, *py, *ny;
#if 0
	register int *ic, *in, *ip;
#else
	register r32 *cz, *pz, *nz;
#endif
	register r32 *res;
	
	px -= 1;
	ppy -= dx;   nny += dx;

	/* first slice: computing along X */
	res = (r32*)aux4Curr;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* first slice: 8-connectivity: computing along Y */
	res = (r32*)auxCurr;
	py = cy = ny = (r32*)aux4Curr;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* first slice: 4-connectivity: computing along Y */
	res = (r32*)aux4Curr;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	  if ( *res == 0 ) continue;
#endif
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;

	/* second slice: computing along X */
	res = (r32*)aux4Next;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* second slice: 8-connectivity: computing along Y */
	res = (r32*)auxNext;
	py = cy = ny = (r32*)aux4Next;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* second slice: 4-connectivity: computing along Y */
	res = (r32*)aux4Next;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	  if ( *res == 0 ) continue;
#endif
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;
	
	/* first slice: result */
#if 0
	ic = (int*)auxCurr; in = (int*)aux4Next;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ &= *in++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
	resBuf += dxy;
#else
	cz = (r32*)auxCurr;   nz = (r32*)aux4Next;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) < (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif
	tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;

	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: computing along X */
	  res = (r32*)aux4Next;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* next slice: 8-connectivity: computing along Y */
	  res = (r32*)auxNext;
	  py = cy = ny = (r32*)aux4Next;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 0 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* next slice: 4-connectivity: computing along Y */
	  res = (r32*)aux4Next;
	  for ( x = 0; x < dx; x++, res++, nny++ )
	    if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  ppy += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	    if ( *res == 0 ) continue;
#endif
	    if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	    if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  }
	  for ( x = 0; x < dx; x++, res++, ppy++ ) 
	    if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  nny += dx;
	  
	  /* current slice: result */
#if 0
	  ic = (int*)auxCurr; in = (int*)aux4Next; ip = (int*)aux4Prev;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ic++ &= *in++ & *ip++;
	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
#else
	  cz = (r32*)auxCurr;   nz = (r32*)aux4Next;
	  pz = (r32*)aux4Prev;
	  for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++, pz++ ) {
	    *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) < (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	  tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}
	
	/* last slice: result */
#if 0
	ic = (int*)auxCurr; ip = (int*)aux4Prev;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ &= *ip++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
#else
	cz = (r32*)auxCurr;   pz = (r32*)aux4Prev;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, pz++ )
	  *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    }
    input = resultBuf;
  }
  /* end */
  free( (void*)localBuf );
}

/* for binary operations only. With respect to grey-level operations,
   it seems that these operations are a little bit faster (a few percents
   on the CPU time), more experiments have to be conducted.
#define _TWO_OPS_( RES, A, B ) RES = ( ((int)(A)) | ((int)(B)) ) 
#define _ONE_OP_( RES, A )     RES = ( ((int)(RES)) | ((int)(A)) ) 
*/
/* for grey-level operations (works for binary operations too) */
/*
#define _TWO_OPS_( RES, A, B ) RES = ( (A) > (B) ? (A) : (B) )
#define _ONE_OP_( RES, A )     if ( (A) > (RES) ) RES = (A)
*/

/* 
   65535
   if the result value is already set to this value
   there is nothing to be done.
   Because it makes the code longer and harder to read
   this test is only performed when at the center of 
   slices. */

/* Morphological operation :

   GreyLevel -> [Binary | GreyLevel ]
           in case of Binary    => 0 == 1
	   in case of GreyLevel => 0 == 0
   Dilation -> [Erosion | Dilation]
           in case of Erosion  => > == '<'
	                          | == '&'
	   in case of Dilation => > == '>'
	                          | == '|'
	   
   4-connectivity: one pointer par neighbor

*/

void GreyLevelDilation_u16 ( void* inputBuf, /* buffer to be resampled */
			  void* resultBuf, /* result buffer */
			  int *theDim, /* dimensions of this buffer */
			  int connectivity, /* connectivity to be used */ 
			  int iterations  /* number of iterations */ )
{
  int conn = 0;                 /* "local" connectivity */
  u16 *localBuf = (void*)NULL; /* buffer for auxiliary computation */
  char *localTab[5];
  void *input;

  int dx, dy, dz, dx1, dy1, dz1;
  int dxy;
  int sliceSize, auxIntSize;
  register int x, y, z;
  int iter;

  if ( iterations <= 0 ) return;


  /* test on connectivity */
  conn = connectivity;
  switch ( conn ) {
  case 4 :
  case 8 :
  case 6 :
  case 10 :
  case 18 :
  case 26 :
    break ;
  default :
    conn = 26;
  }
  
  /* initialization */
  dx = theDim[0];   dx1 = dx - 1;
  dy = theDim[1];   dy1 = dy - 1;
  dz = theDim[2];   dz1 = dz - 1;
  dxy = dx * dy;

  if ( dz == 1 ) {
    switch ( conn ) {
    case 6 :
      conn = 4; break;
    case 10 :
    case 18 :
    case 26 :
      conn = 8; break;
    }
  }

  /* allocation of the auxiliary buffer 
     be sure that the size of each auxiliary slice is 
     a multiple of sizeof(int) for binary computation
   */
  sliceSize = dx * dy * sizeof(u16);
  auxIntSize = 1 + sliceSize / sizeof( int );
  localBuf = (void*)malloc( (unsigned int)(5 * auxIntSize * sizeof(int)) );
  if ( localBuf == (void*)NULL ) return;

  {
    char *t;
    for ( x = 0; x < 5; x ++ ) {
      t = (char*)localBuf;
      t += x * auxIntSize * sizeof( int );
      localTab[x] = (char*)t;
    }
  }

  input =  inputBuf;
  /* iterative processing */
  for ( iter = 0; iter < iterations; iter ++ ) {
    switch ( conn ) {

    /* 4-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 4 :
      {
	register u16 *cur = (u16*)(input);
	u16 *resBuf = (u16*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	register u16 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register u16 *res;
	py -= dx;   px -= 1; 
	ny += dx;   nx += 1; 

	for ( z = 0; z < dz; z ++ ) {
	  res = (u16*)auxCurr;
	  /* first row */
	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; ny++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, res++ ) {
#if 0
	    if ( *cur == 65535 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; ny++; res++;
	  py += dx;

	  /* middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 0
	    if ( *cur == 65535 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, res++ ) {
#if 0
	      if ( *cur == 65535 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    }
#if 0
	    if ( *cur == 65535 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	  }

	  /* last row */
	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; py++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, res++ ) {
#if 0
	    if ( *cur == 65535 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; py++; res++;
	  ny += dx;
	  /* copy */

	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
	}
      }
      break;
      
    /* 8-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X- or Y-lines
    */
    case 8 :
      {
	register u16 *cur = (u16*)(input);
	u16 *resBuf = (u16*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	register u16 *px = cur;
	register u16 *cy, *py, *ny;
	register u16 *res;

	px -= 1;
	
	for ( z = 0; z < dz; z ++ ) {
	  /* computing along X */
	  res = (u16*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 65535 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  py = cy = ny = (u16*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, resBuf++, cy++, ny++ )
	    *resBuf = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, resBuf++ ) {
#if 0
	    if ( *cy == 65535 ) {
	      *resBuf = *cy;
	      continue;
	    }
#endif
	    *resBuf = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	    if ( (*py) > (*resBuf) ) *resBuf = (*py); /* _ONE_OP_( *resBuf, *py ); */
	  }
	  for ( x = 0; x < dx; x++, resBuf++, cy++, py++ ) 
	    *resBuf = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *resBuf, *cy, *py ); */
	}
      }
      break;
      

    /* 6-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 6 :
      {
	register u16 *cur = (u16*)(input);
	u16 *resBuf = (u16*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	void *auxPrev = (void*)localTab[1];
	void *tmp;
	register u16 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register u16 *pz = cur, *nz = cur; 
	register u16 *res;

	pz -= dxy;   py -= dx;   px -= 1; 
	nz += dxy;   ny += dx;   nx += 1; 

	/* first slice */
	res = (u16*)auxCurr;
	/* first slice, first row */
	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, res++ ) {
#if 0
	  if ( *cur == 65535 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;
	py += dx;

	/* first slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 0
	  if ( *cur == 65535 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, res++ ) {
#if 0
	    if ( *cur == 65535 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
#if 0
	  if ( *cur == 65535 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	}

	/* first slice, last row */
	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, res++ ) {
#if 0
	  if ( *cur == 65535 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;
	ny += dx; pz += dxy;
	tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	
	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  res = (u16*)auxCurr;
	  /* middle slice, first row */
#if 0
	  if ( *cur == 65535 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, pz++, res++ ) {
#if 0
	    if ( *cur == 65535 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 65535 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  py += dx;
	  /* middle slice, middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 0
	    if ( *cur == 65535 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, pz++, res++ ) {
#if 0
	      if ( *cur == 65535 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    }
#if 0
	    if ( *cur == 65535 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	  }
	  /* middle slice, last row */
#if 0
	  if ( *cur == 65535 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, pz++, res++ ) {
#if 0
	    if ( *cur == 65535 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 65535 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  ny += dx;
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	}

	/* last slice */
	res = (u16*)auxCurr;
	/* last slice, first row */
	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, pz++, res++ ) {
#if 0
	  if ( *cur == 65535 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;
	py += dx;

	/* last slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 0
	  if ( *cur == 65535 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, pz++, res++ ) {
#if 0
	    if ( *cur == 65535 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 65535 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	}

	/* last slice, last row */
	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, pz++, res++ ) {
#if 0
	  if ( *cur == 65535 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;
      
    /* 26-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X-, Y-lines
    */
    case 26 :
      /* les performances semblent moindres que celles de l'ancienne version
	 (en niveaux de gris), de l'ordre de 2 %
       */
      {
	register u16 *cur = (u16*)(input);
	u16 *resBuf = (u16*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxNext = (void*)localTab[2];
	void *auxPrev = (void*)localTab[3];
	void *tmp;
	register u16 *px = cur;
	register u16 *cy, *py, *ny;
#if 0
	register int *ires, *ic, *in, *ip;
#else
	register u16 *cz, *pz, *nz;
#endif
	register u16 *res;

	px -= 1;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (u16*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 65535 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u16*)auxCurr;
	py = cy = ny = (u16*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 65535 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */

	/* second slice: 8-connectivity */
	/* computing along X */
	res = (u16*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 65535 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u16*)auxNext;
	py = cy = ny = (u16*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x ++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 65535 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	
	/* first slice: result 
	   if we cast slices of auxiliary buffer to be divided
	   by sizeof(int) we may use logical operations
	 */
#if 0
	ires = (int*)auxTmp; ic = (int*)auxCurr; in = (int*)auxNext;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ | *in++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	cz = (u16*)auxCurr;   nz = (u16*)auxNext;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) > (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif

	tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	
	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: 8-connectivity */
	  /* computing along X */
	  res = (u16*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 65535 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (u16*)auxNext;
	  py = cy = ny = (u16*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 65535 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  
#if 0
	  ires = (int*)auxTmp; ip = (int*)auxPrev;
	  ic = (int*)auxCurr; in = (int*)auxNext;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ires++ = *ic++ | *in++ | *ip++;
	  memcpy( (void*)resBuf, auxTmp, sliceSize );
	  resBuf += dxy;
#else
	  pz = (u16*)auxPrev;   cz = (u16*)auxCurr;
	  nz = (u16*)auxNext;
	  for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++, nz++ ) {
	    *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) > (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}

	/* last slice */
#if 0
	ires = (int*)auxTmp; ip = (int*)auxPrev; ic = (int*)auxCurr;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ | *ip++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	pz = (u16*)auxPrev;   cz = (u16*)auxCurr;
	for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++ )
	    *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    case 10 :
      {
	register u16 *cur = (u16*)(input);
	u16 *resBuf = (u16*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxPrev = (void*)localTab[2];
	void *tmp;
	register u16 *px = cur;
	register u16 *cy, *py, *ny;
	register u16 *pz = cur, *nz = cur;
	register u16 *res;

	px -= 1;
	pz -= dxy;   nz += dxy;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (u16*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 65535 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u16*)auxCurr;
	py = cy = ny = (u16*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 65535 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (u16*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, nz++ )
	  if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	pz += dxy;
	tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;

	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* current slice: 8-connectivity */
	  /* computing along X */
	  res = (u16*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 65535 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (u16*)auxCurr;
	  py = cy = ny = (u16*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 65535 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* computing along Z */
	  res = (u16*)auxCurr;
	  for ( x = 0; x < dxy; x ++, res++, pz++, nz++ ) {
#if 0
	    if ( *res == 65535 ) continue;
#endif
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;
	}

	/* last slice: 8-connectivity */
	/* computing along X */
	res = (u16*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 65535 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u16*)auxCurr;
	py = cy = ny = (u16*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 65535 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (u16*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, pz++ )
	  if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;

    case 18 :
      {
	register u16 *cur = (u16*)(input);
	u16 *resBuf = (u16*)(resultBuf);
	void *aux4Prev = (void*)localTab[0];
	void *aux4Curr = (void*)localTab[1];
	void *aux4Next = (void*)localTab[2];
	void *auxCurr = (void*)localTab[3];
	void *auxNext = (void*)localTab[4];
	void *tmp;
	register u16 *px = cur;
	register u16 *ppy = cur, *nny = cur;
	register u16 *cy, *py, *ny;
#if 0
	register int *ic, *in, *ip;
#else
	register u16 *cz, *pz, *nz;
#endif
	register u16 *res;
	
	px -= 1;
	ppy -= dx;   nny += dx;

	/* first slice: computing along X */
	res = (u16*)aux4Curr;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 65535 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* first slice: 8-connectivity: computing along Y */
	res = (u16*)auxCurr;
	py = cy = ny = (u16*)aux4Curr;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 65535 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* first slice: 4-connectivity: computing along Y */
	res = (u16*)aux4Curr;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	  if ( *res == 65535 ) continue;
#endif
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;

	/* second slice: computing along X */
	res = (u16*)aux4Next;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 65535 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* second slice: 8-connectivity: computing along Y */
	res = (u16*)auxNext;
	py = cy = ny = (u16*)aux4Next;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 65535 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* second slice: 4-connectivity: computing along Y */
	res = (u16*)aux4Next;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	  if ( *res == 65535 ) continue;
#endif
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;
	
	/* first slice: result */
#if 0
	ic = (int*)auxCurr; in = (int*)aux4Next;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ |= *in++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
	resBuf += dxy;
#else
	cz = (u16*)auxCurr;   nz = (u16*)aux4Next;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) > (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif
	tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;

	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: computing along X */
	  res = (u16*)aux4Next;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 65535 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* next slice: 8-connectivity: computing along Y */
	  res = (u16*)auxNext;
	  py = cy = ny = (u16*)aux4Next;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 65535 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* next slice: 4-connectivity: computing along Y */
	  res = (u16*)aux4Next;
	  for ( x = 0; x < dx; x++, res++, nny++ )
	    if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  ppy += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	    if ( *res == 65535 ) continue;
#endif
	    if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	    if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  }
	  for ( x = 0; x < dx; x++, res++, ppy++ ) 
	    if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  nny += dx;
	  
	  /* current slice: result */
#if 0
	  ic = (int*)auxCurr; in = (int*)aux4Next; ip = (int*)aux4Prev;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ic++ |= *in++ | *ip++;
	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
#else
	  cz = (u16*)auxCurr;   nz = (u16*)aux4Next;
	  pz = (u16*)aux4Prev;
	  for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++, pz++ ) {
	    *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) > (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	  tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}
	
	/* last slice: result */
#if 0
	ic = (int*)auxCurr; ip = (int*)aux4Prev;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ |= *ip++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
#else
	cz = (u16*)auxCurr;   pz = (u16*)aux4Prev;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, pz++ )
	  *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    }
    input = resultBuf;
  }
  /* end */
  free( (void*)localBuf );
}

/* for binary operations only. With respect to grey-level operations,
   it seems that these operations are a little bit faster (a few percents
   on the CPU time), more experiments have to be conducted.
#define _TWO_OPS_( RES, A, B ) RES = ( ((int)(A)) | ((int)(B)) ) 
#define _ONE_OP_( RES, A )     RES = ( ((int)(RES)) | ((int)(A)) ) 
*/
/* for grey-level operations (works for binary operations too) */
/*
#define _TWO_OPS_( RES, A, B ) RES = ( (A) < (B) ? (A) : (B) )
#define _ONE_OP_( RES, A )     if ( (A) < (RES) ) RES = (A)
*/

/* 
   0
   if the result value is already set to this value
   there is nothing to be done.
   Because it makes the code longer and harder to read
   this test is only performed when at the center of 
   slices. */

/* Morphological operation :

   GreyLevel -> [Binary | GreyLevel ]
           in case of Binary    => 0 == 1
	   in case of GreyLevel => 0 == 0
   Erosion -> [Erosion | Dilation]
           in case of Erosion  => < == '<'
	                          & == '&'
	   in case of Dilation => < == '>'
	                          & == '|'
	   
   4-connectivity: one pointer par neighbor

*/

void GreyLevelErosion_u16 ( void* inputBuf, /* buffer to be resampled */
			  void* resultBuf, /* result buffer */
			  int *theDim, /* dimensions of this buffer */
			  int connectivity, /* connectivity to be used */ 
			  int iterations  /* number of iterations */ )
{
  int conn = 0;                 /* "local" connectivity */
  u16 *localBuf = (void*)NULL; /* buffer for auxiliary computation */
  char *localTab[5];
  void *input;

  int dx, dy, dz, dx1, dy1, dz1;
  int dxy;
  int sliceSize, auxIntSize;
  register int x, y, z;
  int iter;

  if ( iterations <= 0 ) return;


  /* test on connectivity */
  conn = connectivity;
  switch ( conn ) {
  case 4 :
  case 8 :
  case 6 :
  case 10 :
  case 18 :
  case 26 :
    break ;
  default :
    conn = 26;
  }
  
  /* initialization */
  dx = theDim[0];   dx1 = dx - 1;
  dy = theDim[1];   dy1 = dy - 1;
  dz = theDim[2];   dz1 = dz - 1;
  dxy = dx * dy;

  if ( dz == 1 ) {
    switch ( conn ) {
    case 6 :
      conn = 4; break;
    case 10 :
    case 18 :
    case 26 :
      conn = 8; break;
    }
  }

  /* allocation of the auxiliary buffer 
     be sure that the size of each auxiliary slice is 
     a multiple of sizeof(int) for binary computation
   */
  sliceSize = dx * dy * sizeof(u16);
  auxIntSize = 1 + sliceSize / sizeof( int );
  localBuf = (void*)malloc( (unsigned int)(5 * auxIntSize * sizeof(int)) );
  if ( localBuf == (void*)NULL ) return;

  {
    char *t;
    for ( x = 0; x < 5; x ++ ) {
      t = (char*)localBuf;
      t += x * auxIntSize * sizeof( int );
      localTab[x] = (char*)t;
    }
  }

  input =  inputBuf;
  /* iterative processing */
  for ( iter = 0; iter < iterations; iter ++ ) {
    switch ( conn ) {

    /* 4-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 4 :
      {
	register u16 *cur = (u16*)(input);
	u16 *resBuf = (u16*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	register u16 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register u16 *res;
	py -= dx;   px -= 1; 
	ny += dx;   nx += 1; 

	for ( z = 0; z < dz; z ++ ) {
	  res = (u16*)auxCurr;
	  /* first row */
	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; ny++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; ny++; res++;
	  py += dx;

	  /* middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 0
	    if ( *cur == 0 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    }
#if 0
	    if ( *cur == 0 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	  }

	  /* last row */
	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; py++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; py++; res++;
	  ny += dx;
	  /* copy */

	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
	}
      }
      break;
      
    /* 8-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X- or Y-lines
    */
    case 8 :
      {
	register u16 *cur = (u16*)(input);
	u16 *resBuf = (u16*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	register u16 *px = cur;
	register u16 *cy, *py, *ny;
	register u16 *res;

	px -= 1;
	
	for ( z = 0; z < dz; z ++ ) {
	  /* computing along X */
	  res = (u16*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  py = cy = ny = (u16*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, resBuf++, cy++, ny++ )
	    *resBuf = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, resBuf++ ) {
#if 0
	    if ( *cy == 0 ) {
	      *resBuf = *cy;
	      continue;
	    }
#endif
	    *resBuf = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	    if ( (*py) < (*resBuf) ) *resBuf = (*py); /* _ONE_OP_( *resBuf, *py ); */
	  }
	  for ( x = 0; x < dx; x++, resBuf++, cy++, py++ ) 
	    *resBuf = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *resBuf, *cy, *py ); */
	}
      }
      break;
      

    /* 6-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 6 :
      {
	register u16 *cur = (u16*)(input);
	u16 *resBuf = (u16*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	void *auxPrev = (void*)localTab[1];
	void *tmp;
	register u16 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register u16 *pz = cur, *nz = cur; 
	register u16 *res;

	pz -= dxy;   py -= dx;   px -= 1; 
	nz += dxy;   ny += dx;   nx += 1; 

	/* first slice */
	res = (u16*)auxCurr;
	/* first slice, first row */
	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, res++ ) {
#if 0
	  if ( *cur == 0 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;
	py += dx;

	/* first slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	}

	/* first slice, last row */
	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, res++ ) {
#if 0
	  if ( *cur == 0 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;
	ny += dx; pz += dxy;
	tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	
	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  res = (u16*)auxCurr;
	  /* middle slice, first row */
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, pz++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  py += dx;
	  /* middle slice, middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 0
	    if ( *cur == 0 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, pz++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    }
#if 0
	    if ( *cur == 0 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	  }
	  /* middle slice, last row */
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, pz++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  ny += dx;
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	}

	/* last slice */
	res = (u16*)auxCurr;
	/* last slice, first row */
	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, pz++, res++ ) {
#if 0
	  if ( *cur == 0 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;
	py += dx;

	/* last slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, pz++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 0 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	}

	/* last slice, last row */
	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, pz++, res++ ) {
#if 0
	  if ( *cur == 0 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;
      
    /* 26-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X-, Y-lines
    */
    case 26 :
      /* les performances semblent moindres que celles de l'ancienne version
	 (en niveaux de gris), de l'ordre de 2 %
       */
      {
	register u16 *cur = (u16*)(input);
	u16 *resBuf = (u16*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxNext = (void*)localTab[2];
	void *auxPrev = (void*)localTab[3];
	void *tmp;
	register u16 *px = cur;
	register u16 *cy, *py, *ny;
#if 0
	register int *ires, *ic, *in, *ip;
#else
	register u16 *cz, *pz, *nz;
#endif
	register u16 *res;

	px -= 1;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (u16*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u16*)auxCurr;
	py = cy = ny = (u16*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */

	/* second slice: 8-connectivity */
	/* computing along X */
	res = (u16*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u16*)auxNext;
	py = cy = ny = (u16*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x ++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	
	/* first slice: result 
	   if we cast slices of auxiliary buffer to be divided
	   by sizeof(int) we may use logical operations
	 */
#if 0
	ires = (int*)auxTmp; ic = (int*)auxCurr; in = (int*)auxNext;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ & *in++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	cz = (u16*)auxCurr;   nz = (u16*)auxNext;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) < (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif

	tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	
	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: 8-connectivity */
	  /* computing along X */
	  res = (u16*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (u16*)auxNext;
	  py = cy = ny = (u16*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 0 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  
#if 0
	  ires = (int*)auxTmp; ip = (int*)auxPrev;
	  ic = (int*)auxCurr; in = (int*)auxNext;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ires++ = *ic++ & *in++ & *ip++;
	  memcpy( (void*)resBuf, auxTmp, sliceSize );
	  resBuf += dxy;
#else
	  pz = (u16*)auxPrev;   cz = (u16*)auxCurr;
	  nz = (u16*)auxNext;
	  for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++, nz++ ) {
	    *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) < (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}

	/* last slice */
#if 0
	ires = (int*)auxTmp; ip = (int*)auxPrev; ic = (int*)auxCurr;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ & *ip++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	pz = (u16*)auxPrev;   cz = (u16*)auxCurr;
	for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++ )
	    *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    case 10 :
      {
	register u16 *cur = (u16*)(input);
	u16 *resBuf = (u16*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxPrev = (void*)localTab[2];
	void *tmp;
	register u16 *px = cur;
	register u16 *cy, *py, *ny;
	register u16 *pz = cur, *nz = cur;
	register u16 *res;

	px -= 1;
	pz -= dxy;   nz += dxy;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (u16*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u16*)auxCurr;
	py = cy = ny = (u16*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (u16*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, nz++ )
	  if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	pz += dxy;
	tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;

	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* current slice: 8-connectivity */
	  /* computing along X */
	  res = (u16*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (u16*)auxCurr;
	  py = cy = ny = (u16*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 0 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* computing along Z */
	  res = (u16*)auxCurr;
	  for ( x = 0; x < dxy; x ++, res++, pz++, nz++ ) {
#if 0
	    if ( *res == 0 ) continue;
#endif
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;
	}

	/* last slice: 8-connectivity */
	/* computing along X */
	res = (u16*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (u16*)auxCurr;
	py = cy = ny = (u16*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (u16*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, pz++ )
	  if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;

    case 18 :
      {
	register u16 *cur = (u16*)(input);
	u16 *resBuf = (u16*)(resultBuf);
	void *aux4Prev = (void*)localTab[0];
	void *aux4Curr = (void*)localTab[1];
	void *aux4Next = (void*)localTab[2];
	void *auxCurr = (void*)localTab[3];
	void *auxNext = (void*)localTab[4];
	void *tmp;
	register u16 *px = cur;
	register u16 *ppy = cur, *nny = cur;
	register u16 *cy, *py, *ny;
#if 0
	register int *ic, *in, *ip;
#else
	register u16 *cz, *pz, *nz;
#endif
	register u16 *res;
	
	px -= 1;
	ppy -= dx;   nny += dx;

	/* first slice: computing along X */
	res = (u16*)aux4Curr;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* first slice: 8-connectivity: computing along Y */
	res = (u16*)auxCurr;
	py = cy = ny = (u16*)aux4Curr;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* first slice: 4-connectivity: computing along Y */
	res = (u16*)aux4Curr;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	  if ( *res == 0 ) continue;
#endif
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;

	/* second slice: computing along X */
	res = (u16*)aux4Next;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 0 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* second slice: 8-connectivity: computing along Y */
	res = (u16*)auxNext;
	py = cy = ny = (u16*)aux4Next;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 0 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* second slice: 4-connectivity: computing along Y */
	res = (u16*)aux4Next;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	  if ( *res == 0 ) continue;
#endif
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;
	
	/* first slice: result */
#if 0
	ic = (int*)auxCurr; in = (int*)aux4Next;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ &= *in++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
	resBuf += dxy;
#else
	cz = (u16*)auxCurr;   nz = (u16*)aux4Next;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) < (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif
	tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;

	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: computing along X */
	  res = (u16*)aux4Next;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 0 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* next slice: 8-connectivity: computing along Y */
	  res = (u16*)auxNext;
	  py = cy = ny = (u16*)aux4Next;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 0 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* next slice: 4-connectivity: computing along Y */
	  res = (u16*)aux4Next;
	  for ( x = 0; x < dx; x++, res++, nny++ )
	    if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  ppy += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	    if ( *res == 0 ) continue;
#endif
	    if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	    if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  }
	  for ( x = 0; x < dx; x++, res++, ppy++ ) 
	    if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  nny += dx;
	  
	  /* current slice: result */
#if 0
	  ic = (int*)auxCurr; in = (int*)aux4Next; ip = (int*)aux4Prev;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ic++ &= *in++ & *ip++;
	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
#else
	  cz = (u16*)auxCurr;   nz = (u16*)aux4Next;
	  pz = (u16*)aux4Prev;
	  for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++, pz++ ) {
	    *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) < (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	  tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}
	
	/* last slice: result */
#if 0
	ic = (int*)auxCurr; ip = (int*)aux4Prev;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ &= *ip++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
#else
	cz = (u16*)auxCurr;   pz = (u16*)aux4Prev;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, pz++ )
	  *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    }
    input = resultBuf;
  }
  /* end */
  free( (void*)localBuf );
}

/* for binary operations only. With respect to grey-level operations,
   it seems that these operations are a little bit faster (a few percents
   on the CPU time), more experiments have to be conducted.
#define _TWO_OPS_( RES, A, B ) RES = ( ((int)(A)) | ((int)(B)) ) 
#define _ONE_OP_( RES, A )     RES = ( ((int)(RES)) | ((int)(A)) ) 
*/
/* for grey-level operations (works for binary operations too) */
/*
#define _TWO_OPS_( RES, A, B ) RES = ( (A) > (B) ? (A) : (B) )
#define _ONE_OP_( RES, A )     if ( (A) > (RES) ) RES = (A)
*/

/* 
   32767
   if the result value is already set to this value
   there is nothing to be done.
   Because it makes the code longer and harder to read
   this test is only performed when at the center of 
   slices. */

/* Morphological operation :

   GreyLevel -> [Binary | GreyLevel ]
           in case of Binary    => 0 == 1
	   in case of GreyLevel => 0 == 0
   Dilation -> [Erosion | Dilation]
           in case of Erosion  => > == '<'
	                          | == '&'
	   in case of Dilation => > == '>'
	                          | == '|'
	   
   4-connectivity: one pointer par neighbor

*/

void GreyLevelDilation_s16 ( void* inputBuf, /* buffer to be resampled */
			  void* resultBuf, /* result buffer */
			  int *theDim, /* dimensions of this buffer */
			  int connectivity, /* connectivity to be used */ 
			  int iterations  /* number of iterations */ )
{
  int conn = 0;                 /* "local" connectivity */
  s16 *localBuf = (void*)NULL; /* buffer for auxiliary computation */
  char *localTab[5];
  void *input;

  int dx, dy, dz, dx1, dy1, dz1;
  int dxy;
  int sliceSize, auxIntSize;
  register int x, y, z;
  int iter;

  if ( iterations <= 0 ) return;


  /* test on connectivity */
  conn = connectivity;
  switch ( conn ) {
  case 4 :
  case 8 :
  case 6 :
  case 10 :
  case 18 :
  case 26 :
    break ;
  default :
    conn = 26;
  }
  
  /* initialization */
  dx = theDim[0];   dx1 = dx - 1;
  dy = theDim[1];   dy1 = dy - 1;
  dz = theDim[2];   dz1 = dz - 1;
  dxy = dx * dy;

  if ( dz == 1 ) {
    switch ( conn ) {
    case 6 :
      conn = 4; break;
    case 10 :
    case 18 :
    case 26 :
      conn = 8; break;
    }
  }

  /* allocation of the auxiliary buffer 
     be sure that the size of each auxiliary slice is 
     a multiple of sizeof(int) for binary computation
   */
  sliceSize = dx * dy * sizeof(s16);
  auxIntSize = 1 + sliceSize / sizeof( int );
  localBuf = (void*)malloc( (unsigned int)(5 * auxIntSize * sizeof(int)) );
  if ( localBuf == (void*)NULL ) return;

  {
    char *t;
    for ( x = 0; x < 5; x ++ ) {
      t = (char*)localBuf;
      t += x * auxIntSize * sizeof( int );
      localTab[x] = (char*)t;
    }
  }

  input =  inputBuf;
  /* iterative processing */
  for ( iter = 0; iter < iterations; iter ++ ) {
    switch ( conn ) {

    /* 4-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 4 :
      {
	register s16 *cur = (s16*)(input);
	s16 *resBuf = (s16*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	register s16 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register s16 *res;
	py -= dx;   px -= 1; 
	ny += dx;   nx += 1; 

	for ( z = 0; z < dz; z ++ ) {
	  res = (s16*)auxCurr;
	  /* first row */
	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; ny++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, res++ ) {
#if 0
	    if ( *cur == 32767 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; ny++; res++;
	  py += dx;

	  /* middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 0
	    if ( *cur == 32767 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, res++ ) {
#if 0
	      if ( *cur == 32767 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    }
#if 0
	    if ( *cur == 32767 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	  }

	  /* last row */
	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; py++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, res++ ) {
#if 0
	    if ( *cur == 32767 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; py++; res++;
	  ny += dx;
	  /* copy */

	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
	}
      }
      break;
      
    /* 8-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X- or Y-lines
    */
    case 8 :
      {
	register s16 *cur = (s16*)(input);
	s16 *resBuf = (s16*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	register s16 *px = cur;
	register s16 *cy, *py, *ny;
	register s16 *res;

	px -= 1;
	
	for ( z = 0; z < dz; z ++ ) {
	  /* computing along X */
	  res = (s16*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 32767 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  py = cy = ny = (s16*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, resBuf++, cy++, ny++ )
	    *resBuf = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, resBuf++ ) {
#if 0
	    if ( *cy == 32767 ) {
	      *resBuf = *cy;
	      continue;
	    }
#endif
	    *resBuf = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	    if ( (*py) > (*resBuf) ) *resBuf = (*py); /* _ONE_OP_( *resBuf, *py ); */
	  }
	  for ( x = 0; x < dx; x++, resBuf++, cy++, py++ ) 
	    *resBuf = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *resBuf, *cy, *py ); */
	}
      }
      break;
      

    /* 6-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 6 :
      {
	register s16 *cur = (s16*)(input);
	s16 *resBuf = (s16*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	void *auxPrev = (void*)localTab[1];
	void *tmp;
	register s16 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register s16 *pz = cur, *nz = cur; 
	register s16 *res;

	pz -= dxy;   py -= dx;   px -= 1; 
	nz += dxy;   ny += dx;   nx += 1; 

	/* first slice */
	res = (s16*)auxCurr;
	/* first slice, first row */
	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, res++ ) {
#if 0
	  if ( *cur == 32767 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;
	py += dx;

	/* first slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 0
	  if ( *cur == 32767 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, res++ ) {
#if 0
	    if ( *cur == 32767 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
#if 0
	  if ( *cur == 32767 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	}

	/* first slice, last row */
	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, res++ ) {
#if 0
	  if ( *cur == 32767 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;
	ny += dx; pz += dxy;
	tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	
	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  res = (s16*)auxCurr;
	  /* middle slice, first row */
#if 0
	  if ( *cur == 32767 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, pz++, res++ ) {
#if 0
	    if ( *cur == 32767 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 32767 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  py += dx;
	  /* middle slice, middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 0
	    if ( *cur == 32767 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, pz++, res++ ) {
#if 0
	      if ( *cur == 32767 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    }
#if 0
	    if ( *cur == 32767 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	  }
	  /* middle slice, last row */
#if 0
	  if ( *cur == 32767 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, pz++, res++ ) {
#if 0
	    if ( *cur == 32767 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 32767 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  ny += dx;
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	}

	/* last slice */
	res = (s16*)auxCurr;
	/* last slice, first row */
	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, pz++, res++ ) {
#if 0
	  if ( *cur == 32767 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) > (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;
	py += dx;

	/* last slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 0
	  if ( *cur == 32767 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, pz++, res++ ) {
#if 0
	    if ( *cur == 32767 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == 32767 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) > (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	}

	/* last slice, last row */
	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, pz++, res++ ) {
#if 0
	  if ( *cur == 32767 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) > (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) > (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;
      
    /* 26-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X-, Y-lines
    */
    case 26 :
      /* les performances semblent moindres que celles de l'ancienne version
	 (en niveaux de gris), de l'ordre de 2 %
       */
      {
	register s16 *cur = (s16*)(input);
	s16 *resBuf = (s16*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxNext = (void*)localTab[2];
	void *auxPrev = (void*)localTab[3];
	void *tmp;
	register s16 *px = cur;
	register s16 *cy, *py, *ny;
#if 0
	register int *ires, *ic, *in, *ip;
#else
	register s16 *cz, *pz, *nz;
#endif
	register s16 *res;

	px -= 1;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (s16*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 32767 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (s16*)auxCurr;
	py = cy = ny = (s16*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 32767 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */

	/* second slice: 8-connectivity */
	/* computing along X */
	res = (s16*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 32767 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (s16*)auxNext;
	py = cy = ny = (s16*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x ++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 32767 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	
	/* first slice: result 
	   if we cast slices of auxiliary buffer to be divided
	   by sizeof(int) we may use logical operations
	 */
#if 0
	ires = (int*)auxTmp; ic = (int*)auxCurr; in = (int*)auxNext;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ | *in++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	cz = (s16*)auxCurr;   nz = (s16*)auxNext;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) > (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif

	tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	
	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: 8-connectivity */
	  /* computing along X */
	  res = (s16*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 32767 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (s16*)auxNext;
	  py = cy = ny = (s16*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 32767 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  
#if 0
	  ires = (int*)auxTmp; ip = (int*)auxPrev;
	  ic = (int*)auxCurr; in = (int*)auxNext;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ires++ = *ic++ | *in++ | *ip++;
	  memcpy( (void*)resBuf, auxTmp, sliceSize );
	  resBuf += dxy;
#else
	  pz = (s16*)auxPrev;   cz = (s16*)auxCurr;
	  nz = (s16*)auxNext;
	  for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++, nz++ ) {
	    *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) > (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}

	/* last slice */
#if 0
	ires = (int*)auxTmp; ip = (int*)auxPrev; ic = (int*)auxCurr;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ | *ip++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	pz = (s16*)auxPrev;   cz = (s16*)auxCurr;
	for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++ )
	    *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    case 10 :
      {
	register s16 *cur = (s16*)(input);
	s16 *resBuf = (s16*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxPrev = (void*)localTab[2];
	void *tmp;
	register s16 *px = cur;
	register s16 *cy, *py, *ny;
	register s16 *pz = cur, *nz = cur;
	register s16 *res;

	px -= 1;
	pz -= dxy;   nz += dxy;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (s16*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 32767 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (s16*)auxCurr;
	py = cy = ny = (s16*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 32767 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (s16*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, nz++ )
	  if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	pz += dxy;
	tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;

	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* current slice: 8-connectivity */
	  /* computing along X */
	  res = (s16*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 32767 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (s16*)auxCurr;
	  py = cy = ny = (s16*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 32767 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* computing along Z */
	  res = (s16*)auxCurr;
	  for ( x = 0; x < dxy; x ++, res++, pz++, nz++ ) {
#if 0
	    if ( *res == 32767 ) continue;
#endif
	    if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    if ( (*nz) > (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;
	}

	/* last slice: 8-connectivity */
	/* computing along X */
	res = (s16*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 32767 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (s16*)auxCurr;
	py = cy = ny = (s16*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 32767 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (s16*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, pz++ )
	  if ( (*pz) > (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;

    case 18 :
      {
	register s16 *cur = (s16*)(input);
	s16 *resBuf = (s16*)(resultBuf);
	void *aux4Prev = (void*)localTab[0];
	void *aux4Curr = (void*)localTab[1];
	void *aux4Next = (void*)localTab[2];
	void *auxCurr = (void*)localTab[3];
	void *auxNext = (void*)localTab[4];
	void *tmp;
	register s16 *px = cur;
	register s16 *ppy = cur, *nny = cur;
	register s16 *cy, *py, *ny;
#if 0
	register int *ic, *in, *ip;
#else
	register s16 *cz, *pz, *nz;
#endif
	register s16 *res;
	
	px -= 1;
	ppy -= dx;   nny += dx;

	/* first slice: computing along X */
	res = (s16*)aux4Curr;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 32767 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* first slice: 8-connectivity: computing along Y */
	res = (s16*)auxCurr;
	py = cy = ny = (s16*)aux4Curr;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 32767 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* first slice: 4-connectivity: computing along Y */
	res = (s16*)aux4Curr;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	  if ( *res == 32767 ) continue;
#endif
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;

	/* second slice: computing along X */
	res = (s16*)aux4Next;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == 32767 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* second slice: 8-connectivity: computing along Y */
	res = (s16*)auxNext;
	py = cy = ny = (s16*)aux4Next;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == 32767 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* second slice: 4-connectivity: computing along Y */
	res = (s16*)aux4Next;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	  if ( *res == 32767 ) continue;
#endif
	  if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;
	
	/* first slice: result */
#if 0
	ic = (int*)auxCurr; in = (int*)aux4Next;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ |= *in++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
	resBuf += dxy;
#else
	cz = (s16*)auxCurr;   nz = (s16*)aux4Next;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) > (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif
	tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;

	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: computing along X */
	  res = (s16*)aux4Next;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == 32767 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) > (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) > (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) > (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* next slice: 8-connectivity: computing along Y */
	  res = (s16*)auxNext;
	  py = cy = ny = (s16*)aux4Next;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == 32767 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) > (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) > (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) > (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* next slice: 4-connectivity: computing along Y */
	  res = (s16*)aux4Next;
	  for ( x = 0; x < dx; x++, res++, nny++ )
	    if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  ppy += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	    if ( *res == 32767 ) continue;
#endif
	    if ( (*nny) > (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	    if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  }
	  for ( x = 0; x < dx; x++, res++, ppy++ ) 
	    if ( (*ppy) > (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  nny += dx;
	  
	  /* current slice: result */
#if 0
	  ic = (int*)auxCurr; in = (int*)aux4Next; ip = (int*)aux4Prev;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ic++ |= *in++ | *ip++;
	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
#else
	  cz = (s16*)auxCurr;   nz = (s16*)aux4Next;
	  pz = (s16*)aux4Prev;
	  for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++, pz++ ) {
	    *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) > (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	  tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}
	
	/* last slice: result */
#if 0
	ic = (int*)auxCurr; ip = (int*)aux4Prev;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ |= *ip++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
#else
	cz = (s16*)auxCurr;   pz = (s16*)aux4Prev;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, pz++ )
	  *resBuf = ( (*cz) > (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    }
    input = resultBuf;
  }
  /* end */
  free( (void*)localBuf );
}

/* for binary operations only. With respect to grey-level operations,
   it seems that these operations are a little bit faster (a few percents
   on the CPU time), more experiments have to be conducted.
#define _TWO_OPS_( RES, A, B ) RES = ( ((int)(A)) | ((int)(B)) ) 
#define _ONE_OP_( RES, A )     RES = ( ((int)(RES)) | ((int)(A)) ) 
*/
/* for grey-level operations (works for binary operations too) */
/*
#define _TWO_OPS_( RES, A, B ) RES = ( (A) < (B) ? (A) : (B) )
#define _ONE_OP_( RES, A )     if ( (A) < (RES) ) RES = (A)
*/

/* 
   -32768
   if the result value is already set to this value
   there is nothing to be done.
   Because it makes the code longer and harder to read
   this test is only performed when at the center of 
   slices. */

/* Morphological operation :

   GreyLevel -> [Binary | GreyLevel ]
           in case of Binary    => 0 == 1
	   in case of GreyLevel => 0 == 0
   Erosion -> [Erosion | Dilation]
           in case of Erosion  => < == '<'
	                          & == '&'
	   in case of Dilation => < == '>'
	                          & == '|'
	   
   4-connectivity: one pointer par neighbor

*/

void GreyLevelErosion_s16 ( void* inputBuf, /* buffer to be resampled */
			  void* resultBuf, /* result buffer */
			  int *theDim, /* dimensions of this buffer */
			  int connectivity, /* connectivity to be used */ 
			  int iterations  /* number of iterations */ )
{
  int conn = 0;                 /* "local" connectivity */
  s16 *localBuf = (void*)NULL; /* buffer for auxiliary computation */
  char *localTab[5];
  void *input;

  int dx, dy, dz, dx1, dy1, dz1;
  int dxy;
  int sliceSize, auxIntSize;
  register int x, y, z;
  int iter;

  if ( iterations <= 0 ) return;


  /* test on connectivity */
  conn = connectivity;
  switch ( conn ) {
  case 4 :
  case 8 :
  case 6 :
  case 10 :
  case 18 :
  case 26 :
    break ;
  default :
    conn = 26;
  }
  
  /* initialization */
  dx = theDim[0];   dx1 = dx - 1;
  dy = theDim[1];   dy1 = dy - 1;
  dz = theDim[2];   dz1 = dz - 1;
  dxy = dx * dy;

  if ( dz == 1 ) {
    switch ( conn ) {
    case 6 :
      conn = 4; break;
    case 10 :
    case 18 :
    case 26 :
      conn = 8; break;
    }
  }

  /* allocation of the auxiliary buffer 
     be sure that the size of each auxiliary slice is 
     a multiple of sizeof(int) for binary computation
   */
  sliceSize = dx * dy * sizeof(s16);
  auxIntSize = 1 + sliceSize / sizeof( int );
  localBuf = (void*)malloc( (unsigned int)(5 * auxIntSize * sizeof(int)) );
  if ( localBuf == (void*)NULL ) return;

  {
    char *t;
    for ( x = 0; x < 5; x ++ ) {
      t = (char*)localBuf;
      t += x * auxIntSize * sizeof( int );
      localTab[x] = (char*)t;
    }
  }

  input =  inputBuf;
  /* iterative processing */
  for ( iter = 0; iter < iterations; iter ++ ) {
    switch ( conn ) {

    /* 4-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 4 :
      {
	register s16 *cur = (s16*)(input);
	s16 *resBuf = (s16*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	register s16 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register s16 *res;
	py -= dx;   px -= 1; 
	ny += dx;   nx += 1; 

	for ( z = 0; z < dz; z ++ ) {
	  res = (s16*)auxCurr;
	  /* first row */
	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; ny++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, res++ ) {
#if 0
	    if ( *cur == -32768 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; ny++; res++;
	  py += dx;

	  /* middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 0
	    if ( *cur == -32768 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, res++ ) {
#if 0
	      if ( *cur == -32768 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    }
#if 0
	    if ( *cur == -32768 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; res++;
	  }

	  /* last row */
	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  cur++; px++; nx++; py++; res++;

	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, res++ ) {
#if 0
	    if ( *cur == -32768 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  }

	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  cur++; px++; nx++; py++; res++;
	  ny += dx;
	  /* copy */

	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
	}
      }
      break;
      
    /* 8-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X- or Y-lines
    */
    case 8 :
      {
	register s16 *cur = (s16*)(input);
	s16 *resBuf = (s16*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	register s16 *px = cur;
	register s16 *cy, *py, *ny;
	register s16 *res;

	px -= 1;
	
	for ( z = 0; z < dz; z ++ ) {
	  /* computing along X */
	  res = (s16*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == -32768 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  py = cy = ny = (s16*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, resBuf++, cy++, ny++ )
	    *resBuf = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, resBuf++ ) {
#if 0
	    if ( *cy == -32768 ) {
	      *resBuf = *cy;
	      continue;
	    }
#endif
	    *resBuf = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *resBuf, *cy, *ny ); */
	    if ( (*py) < (*resBuf) ) *resBuf = (*py); /* _ONE_OP_( *resBuf, *py ); */
	  }
	  for ( x = 0; x < dx; x++, resBuf++, cy++, py++ ) 
	    *resBuf = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *resBuf, *cy, *py ); */
	}
      }
      break;
      

    /* 6-connectivity :
       there is one pointer for each neighbor.
       the result is computed by comparison between
       the current point and its [2|3|4] neighbors.
       There is no "binary acceleration" at the corners.
       
    */
    case 6 :
      {
	register s16 *cur = (s16*)(input);
	s16 *resBuf = (s16*)(resultBuf);
	void *auxCurr = (void*)localTab[0];
	void *auxPrev = (void*)localTab[1];
	void *tmp;
	register s16 *px = cur, *nx = cur, *py = cur, *ny = cur;
	register s16 *pz = cur, *nz = cur; 
	register s16 *res;

	pz -= dxy;   py -= dx;   px -= 1; 
	nz += dxy;   ny += dx;   nx += 1; 

	/* first slice */
	res = (s16*)auxCurr;
	/* first slice, first row */
	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, res++ ) {
#if 0
	  if ( *cur == -32768 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; ny++; nz++; res++;
	py += dx;

	/* first slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 0
	  if ( *cur == -32768 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, res++ ) {
#if 0
	    if ( *cur == -32768 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
#if 0
	  if ( *cur == -32768 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; nz++; res++;
	}

	/* first slice, last row */
	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, res++ ) {
#if 0
	  if ( *cur == -32768 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	}

	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	cur++; px++; nx++; py++; nz++; res++;
	ny += dx; pz += dxy;
	tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	
	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  res = (s16*)auxCurr;
	  /* middle slice, first row */
#if 0
	  if ( *cur == -32768 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, nz++, pz++, res++ ) {
#if 0
	    if ( *cur == -32768 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == -32768 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; ny++; nz++; pz++; res++;
	  py += dx;
	  /* middle slice, middle rows */
	  for ( y = 1; y < dy1; y ++ ) {
#if 0
	    if ( *cur == -32768 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, nz++, pz++, res++ ) {
#if 0
	      if ( *cur == -32768 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	      if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    }
#if 0
	    if ( *cur == -32768 ) *res = *cur;
	    else {
#endif
	      *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	      if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	      if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	      if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	    }
#endif
	    cur++; px++; nx++; py++; ny++; nz++; pz++; res++;
	  }
	  /* middle slice, last row */
#if 0
	  if ( *cur == -32768 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, nz++, pz++, res++ ) {
#if 0
	    if ( *cur == -32768 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == -32768 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; nz++; pz++; res++;
	  ny += dx;
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev;   auxPrev = auxCurr;   auxCurr = tmp;
	}

	/* last slice */
	res = (s16*)auxCurr;
	/* last slice, first row */
	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, ny++, pz++, res++ ) {
#if 0
	  if ( *cur == -32768 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) < (*ny) ? (*cur) : (*ny) ); /* _TWO_OPS_( *res, *cur, *ny ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; ny++; pz++; res++;
	py += dx;

	/* last slice, middle rows */
	for ( y = 1; y < dy1; y ++ ) {
#if 0
	  if ( *cur == -32768 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, ny++, pz++, res++ ) {
#if 0
	    if ( *cur == -32768 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	  }
#if 0
	  if ( *cur == -32768 ) *res = *cur;
	  else {
#endif
	    *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	    if ( (*ny) < (*res) ) *res = (*ny); /* _ONE_OP_( *res, *ny ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
#if 0
	  }
#endif
	  cur++; px++; nx++; py++; ny++; pz++; res++;
	}

	/* last slice, last row */
	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	for ( x = 1; x < dx1; x++, cur++, px++, nx++, py++, pz++, res++ ) {
#if 0
	  if ( *cur == -32768 ) {
	    *res = *cur;
	    continue;
	  }
#endif
	  *res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	  if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  if ( (*nx) < (*res) ) *res = (*nx); /* _ONE_OP_( *res, *nx ); */
	  if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	}

	*res = ( (*cur) < (*py) ? (*cur) : (*py) ); /* _TWO_OPS_( *res, *cur, *py ); */
	if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	cur++; px++; nx++; py++; pz++; res++;

	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;
      
    /* 26-connectivity :
       we use separability. 
       Ther is no "binary acceleration" at the end of the 
       X-, Y-lines
    */
    case 26 :
      /* les performances semblent moindres que celles de l'ancienne version
	 (en niveaux de gris), de l'ordre de 2 %
       */
      {
	register s16 *cur = (s16*)(input);
	s16 *resBuf = (s16*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxNext = (void*)localTab[2];
	void *auxPrev = (void*)localTab[3];
	void *tmp;
	register s16 *px = cur;
	register s16 *cy, *py, *ny;
#if 0
	register int *ires, *ic, *in, *ip;
#else
	register s16 *cz, *pz, *nz;
#endif
	register s16 *res;

	px -= 1;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (s16*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == -32768 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (s16*)auxCurr;
	py = cy = ny = (s16*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == -32768 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */

	/* second slice: 8-connectivity */
	/* computing along X */
	res = (s16*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == -32768 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (s16*)auxNext;
	py = cy = ny = (s16*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x ++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == -32768 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	
	/* first slice: result 
	   if we cast slices of auxiliary buffer to be divided
	   by sizeof(int) we may use logical operations
	 */
#if 0
	ires = (int*)auxTmp; ic = (int*)auxCurr; in = (int*)auxNext;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ & *in++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	cz = (s16*)auxCurr;   nz = (s16*)auxNext;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) < (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif

	tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	
	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: 8-connectivity */
	  /* computing along X */
	  res = (s16*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == -32768 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (s16*)auxNext;
	  py = cy = ny = (s16*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == -32768 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  
#if 0
	  ires = (int*)auxTmp; ip = (int*)auxPrev;
	  ic = (int*)auxCurr; in = (int*)auxNext;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ires++ = *ic++ & *in++ & *ip++;
	  memcpy( (void*)resBuf, auxTmp, sliceSize );
	  resBuf += dxy;
#else
	  pz = (s16*)auxPrev;   cz = (s16*)auxCurr;
	  nz = (s16*)auxNext;
	  for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++, nz++ ) {
	    *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) < (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}

	/* last slice */
#if 0
	ires = (int*)auxTmp; ip = (int*)auxPrev; ic = (int*)auxCurr;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ires++ = *ic++ & *ip++;
	memcpy( (void*)resBuf, auxTmp, sliceSize );
	resBuf += dxy;
#else
	pz = (s16*)auxPrev;   cz = (s16*)auxCurr;
	for ( x = 0; x < dxy ; x++, resBuf++, pz++, cz++ )
	    *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    case 10 :
      {
	register s16 *cur = (s16*)(input);
	s16 *resBuf = (s16*)(resultBuf);
	void *auxTmp = (void*)localTab[0];
	void *auxCurr = (void*)localTab[1];
	void *auxPrev = (void*)localTab[2];
	void *tmp;
	register s16 *px = cur;
	register s16 *cy, *py, *ny;
	register s16 *pz = cur, *nz = cur;
	register s16 *res;

	px -= 1;
	pz -= dxy;   nz += dxy;

	/* first slice: 8-connectivity */
	/* computing along X */
	res = (s16*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x ++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == -32768 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (s16*)auxCurr;
	py = cy = ny = (s16*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == -32768 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (s16*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, nz++ )
	  if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	pz += dxy;
	tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;

	/* middle slices */
	for ( z = 1; z < dz1; z ++ ) {
	  /* current slice: 8-connectivity */
	  /* computing along X */
	  res = (s16*)auxTmp;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == -32768 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* computing along Y */
	  res = (s16*)auxCurr;
	  py = cy = ny = (s16*)auxTmp;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == -32768 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* computing along Z */
	  res = (s16*)auxCurr;
	  for ( x = 0; x < dxy; x ++, res++, pz++, nz++ ) {
#if 0
	    if ( *res == -32768 ) continue;
#endif
	    if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	    if ( (*nz) < (*res) ) *res = (*nz); /* _ONE_OP_( *res, *nz ); */
	  }
	  /* copy of previous slice */
	  memcpy( (void*)resBuf, auxPrev, sliceSize );
	  resBuf += dxy;
	  tmp = auxPrev; auxPrev = auxCurr; auxCurr = tmp;
	}

	/* last slice: 8-connectivity */
	/* computing along X */
	res = (s16*)auxTmp;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == -32768 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* computing along Y */
	res = (s16*)auxCurr;
	py = cy = ny = (s16*)auxTmp;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == -32768 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* computing along Z */
	res = (s16*)auxCurr;
	for ( x = 0; x < dxy; x ++, res++, pz++ )
	  if ( (*pz) < (*res) ) *res = (*pz); /* _ONE_OP_( *res, *pz ); */
	/* copy of previous slice */
	memcpy( (void*)resBuf, auxPrev, sliceSize );
	resBuf += dxy;
	/* copy of current slice */
	memcpy( (void*)resBuf, auxCurr, sliceSize );
      }
      break;

    case 18 :
      {
	register s16 *cur = (s16*)(input);
	s16 *resBuf = (s16*)(resultBuf);
	void *aux4Prev = (void*)localTab[0];
	void *aux4Curr = (void*)localTab[1];
	void *aux4Next = (void*)localTab[2];
	void *auxCurr = (void*)localTab[3];
	void *auxNext = (void*)localTab[4];
	void *tmp;
	register s16 *px = cur;
	register s16 *ppy = cur, *nny = cur;
	register s16 *cy, *py, *ny;
#if 0
	register int *ic, *in, *ip;
#else
	register s16 *cz, *pz, *nz;
#endif
	register s16 *res;
	
	px -= 1;
	ppy -= dx;   nny += dx;

	/* first slice: computing along X */
	res = (s16*)aux4Curr;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == -32768 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* first slice: 8-connectivity: computing along Y */
	res = (s16*)auxCurr;
	py = cy = ny = (s16*)aux4Curr;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == -32768 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* first slice: 4-connectivity: computing along Y */
	res = (s16*)aux4Curr;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	  if ( *res == -32768 ) continue;
#endif
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;

	/* second slice: computing along X */
	res = (s16*)aux4Next;
	for ( y = 0; y < dy; y ++ ) {
	  *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	  cur++; px++; res++;
	  for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	    if ( *cur == -32768 ) {
	      *res = *cur;
	      continue;
	    }
#endif
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	  }
	  *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	  cur++; px++; res++;
	}
	/* second slice: 8-connectivity: computing along Y */
	res = (s16*)auxNext;
	py = cy = ny = (s16*)aux4Next;
	py -= dx; ny += dx;
	for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	py += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	  if ( *cy == -32768 ) {
	    *res = *cy;
	    continue;
	  }
#endif
	  *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	}
	for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	  *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	/* second slice: 4-connectivity: computing along Y */
	res = (s16*)aux4Next;
	for ( x = 0; x < dx; x++, res++, nny++ )
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	ppy += dx;
	for ( y = 1; y < dy1; y ++ ) 
	for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	  if ( *res == -32768 ) continue;
#endif
	  if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	}
	for ( x = 0; x < dx; x++, res++, ppy++ ) 
	  if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	nny += dx;
	
	/* first slice: result */
#if 0
	ic = (int*)auxCurr; in = (int*)aux4Next;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ &= *in++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
	resBuf += dxy;
#else
	cz = (s16*)auxCurr;   nz = (s16*)aux4Next;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++ )
	  *resBuf = ( (*cz) < (*nz) ? (*cz) : (*nz) ); /* _TWO_OPS_( *resBuf, *cz, *nz ); */
#endif
	tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;

	/* middle slice */
	for ( z = 1; z < dz1; z ++ ) {
	  /* next slice: computing along X */
	  res = (s16*)aux4Next;
	  for ( y = 0; y < dy; y ++ ) {
	    *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	    cur++; px++; res++;
	    for ( x = 1; x < dx1; x++, cur++, px++, res++ ) {
#if 0
	      if ( *cur == -32768 ) {
		*res = *cur;
		continue;
	      }
#endif
	      *res = ( (*cur) < (px[2]) ? (*cur) : (px[2]) ); /* _TWO_OPS_( *res, *cur, px[2] ); */
	      if ( (*px) < (*res) ) *res = (*px); /* _ONE_OP_( *res, *px ); */
	    }
	    *res = ( (*cur) < (*px) ? (*cur) : (*px) ); /* _TWO_OPS_( *res, *cur, *px ); */
	    cur++; px++; res++;
	  }
	  /* next slice: 8-connectivity: computing along Y */
	  res = (s16*)auxNext;
	  py = cy = ny = (s16*)aux4Next;
	  py -= dx; ny += dx;
	  for ( x = 0; x < dx; x++, res++, cy++, ny++ )
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	  py += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, cy++, ny++, py++, res++ ) {
#if 0
	    if ( *cy == -32768 ) {
	      *res = *cy;
	      continue;
	    }
#endif
	    *res = ( (*cy) < (*ny) ? (*cy) : (*ny) ); /* _TWO_OPS_( *res, *cy, *ny ); */
	    if ( (*py) < (*res) ) *res = (*py); /* _ONE_OP_( *res, *py ); */
	  }
	  for ( x = 0; x < dx; x++, res++, cy++, py++ ) 
	    *res = ( (*cy) < (*py) ? (*cy) : (*py) ); /* _TWO_OPS_( *res, *cy, *py ); */
	  /* next slice: 4-connectivity: computing along Y */
	  res = (s16*)aux4Next;
	  for ( x = 0; x < dx; x++, res++, nny++ )
	    if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	  ppy += dx;
	  for ( y = 1; y < dy1; y ++ ) 
	  for ( x = 0; x < dx; x++, nny++, ppy++, res++ ) {
#if 0
	    if ( *res == -32768 ) continue;
#endif
	    if ( (*nny) < (*res) ) *res = (*nny); /* _ONE_OP_( *res, *nny ); */
	    if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  }
	  for ( x = 0; x < dx; x++, res++, ppy++ ) 
	    if ( (*ppy) < (*res) ) *res = (*ppy); /* _ONE_OP_( *res, *ppy ); */
	  nny += dx;
	  
	  /* current slice: result */
#if 0
	  ic = (int*)auxCurr; in = (int*)aux4Next; ip = (int*)aux4Prev;
	  for ( x = 0; x < auxIntSize; x ++ )
	    *ic++ &= *in++ & *ip++;
	  memcpy( (void*)resBuf, auxCurr, sliceSize );
	  resBuf += dxy;
#else
	  cz = (s16*)auxCurr;   nz = (s16*)aux4Next;
	  pz = (s16*)aux4Prev;
	  for ( x = 0; x < dxy ; x++, resBuf++, cz++, nz++, pz++ ) {
	    *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
	    if ( (*nz) < (*resBuf) ) *resBuf = (*nz); /* _ONE_OP_( *resBuf, *nz ); */
	  }
#endif
	  tmp = aux4Prev; aux4Prev = aux4Curr; aux4Curr = aux4Next; aux4Next = tmp;
	  tmp = auxCurr; auxCurr = auxNext; auxNext = tmp;
	}
	
	/* last slice: result */
#if 0
	ic = (int*)auxCurr; ip = (int*)aux4Prev;
	for ( x = 0; x < auxIntSize; x ++ )
	  *ic++ &= *ip++;
	memcpy( (void*)resBuf, auxCurr, sliceSize );
#else
	cz = (s16*)auxCurr;   pz = (s16*)aux4Prev;
	for ( x = 0; x < dxy ; x++, resBuf++, cz++, pz++ )
	  *resBuf = ( (*cz) < (*pz) ? (*cz) : (*pz) ); /* _TWO_OPS_( *resBuf, *cz, *pz ); */
#endif
      }
      break;

    }
    input = resultBuf;
  }
  /* end */
  free( (void*)localBuf );
}

