/*************************************************************************
 * reech-def.c -
 *
 * $Id: reech-def.begin,v 1.2 2000/10/18 08:45:56 greg Exp $
 *
 * Copyright (c) INRIA 1999
 *
 * AUTHOR:
 * Gregoire Malandain (greg@sophia.inria.fr)
 * 
 * CREATION DATE: 
 *
 *
 * ADDITIONS, CHANGES
 *	
 *	
 *	
 *
 */


/* CAUTION
   DO NOT EDIT THIS FILE,
   UNLESS YOU HAVE A VERY GOOD REASON 
 */


#include <stdio.h>
#include <stdlib.h>

#include <typedefs.h>
#include <chunks.h>

#include <reech-def.h>




#define _CONVERTR_(R) ( R )
#define _CONVERTI_(R) ( (R) >= 0.0 ? ((int)((R)+0.5)) : ((int)((R)-0.5)) )
static int _verbose_ = 1;





void setVerboseInReechDef( int v )
{
  _verbose_ = v;
}

void incrementVerboseInReechDef(  )
{
  _verbose_ ++;
}

void decrementVerboseInReechDef(  )
{
  _verbose_ --;
  if ( _verbose_ < 0 ) _verbose_ = 0;
}





typedef struct {
  void* theBuf; /* buffer to be resampled */
  int *theDim; /* dimensions of this buffer */
  void* resBuf; /* result buffer */
  int *resDim;  /* dimensions of this buffer */
  void** theDef;   /* deformation field */
  int *defDim; /* dimensions of these buffers */
  double* mat_aft;  /* transformation matrix */
  double* mat_bef;  /* transformation matrix */
  float gain;
  float bias;
} _VectorFieldResamplingParam;





static void *_Reech3DTriLinVectorField_r32_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u8 *tbuf = (u8*)theBuf;
  u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (u8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    *rbuf = *tpt;
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (u8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r32_u8 ( void* theBuf, /* buffer to be resampled */
			     int *theDim,  /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     r32** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
			     double* mat_aft,  /* transformation matrix */
			     double* mat_bef  /* transformation matrix */
			     )
{
  char *proc = "Reech3DTriLinVectorField_r32_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r32_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r32_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u8 *tbuf = (u8*)theBuf;
  u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (u8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	res = res * g + b;
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (double)(*tpt) * g + b;
	    *rbuf = (u8)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  res = res * g + b;
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  res = res * g + b;
	 *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	res = res * g + b;
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  res = res * g + b;
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	res = res * g + b;
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
	*rbuf = (u8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r32_u8 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r32** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r32_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r32_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r32_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  int rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u8 *tbuf = (u8*)theBuf;
  register u8 *rbuf = (u8*)resBuf;
  
  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;
  
  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\n", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	  
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + iz * tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r32_u8 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r32** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech3DNearestVectorField_r32_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r32_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r32_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u8 *tbuf = (u8*)theBuf;
  u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (u8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  *rbuf = *tpt;
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (u8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r32_u8 ( void* theBuf, /* buffer to be resampled */
						    int *theDim,  /* dimensions of this buffer */
						    void* resBuf, /* result buffer */
						    int *resDim,  /* dimensions of this buffer */
						    r32** theDef, /* deformations */
						    int *defDim, /* dimensions of these buffers */
						    double* mat_aft,  /* transformation matrix */
						    double* mat_bef  /* transformation matrix */
						    )
{
  char *proc = "Reech2DTriLinVectorField_r32_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r32_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r32_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u8 *tbuf = (u8*)theBuf;
  u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (u8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	res = res * g + b;
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  res = (double)(*tpt) * g + b;
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	res = (double)(*tpt) * g + b;
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (u8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r32_u8 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r32** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r32_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r32_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r32_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u8 *tbuf = (u8*)theBuf;
  register u8 *rbuf = (u8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + k * tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r32_u8 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r32** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech2DNearestVectorField_r32_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r32_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r32_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s8 *tbuf = (s8*)theBuf;
  s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (s8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    *rbuf = *tpt;
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (s8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r32_s8 ( void* theBuf, /* buffer to be resampled */
			     int *theDim,  /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     r32** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
			     double* mat_aft,  /* transformation matrix */
			     double* mat_bef  /* transformation matrix */
			     )
{
  char *proc = "Reech3DTriLinVectorField_r32_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r32_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r32_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s8 *tbuf = (s8*)theBuf;
  s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (s8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	res = res * g + b;
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (double)(*tpt) * g + b;
	    *rbuf = (s8)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  res = res * g + b;
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  res = res * g + b;
	 *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	res = res * g + b;
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  res = res * g + b;
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	res = res * g + b;
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
	*rbuf = (s8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r32_s8 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r32** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r32_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r32_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r32_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  int rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s8 *tbuf = (s8*)theBuf;
  register s8 *rbuf = (s8*)resBuf;
  
  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;
  
  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\n", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	  
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + iz * tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r32_s8 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r32** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech3DNearestVectorField_r32_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r32_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r32_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s8 *tbuf = (s8*)theBuf;
  s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (s8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  *rbuf = *tpt;
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (s8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r32_s8 ( void* theBuf, /* buffer to be resampled */
						    int *theDim,  /* dimensions of this buffer */
						    void* resBuf, /* result buffer */
						    int *resDim,  /* dimensions of this buffer */
						    r32** theDef, /* deformations */
						    int *defDim, /* dimensions of these buffers */
						    double* mat_aft,  /* transformation matrix */
						    double* mat_bef  /* transformation matrix */
						    )
{
  char *proc = "Reech2DTriLinVectorField_r32_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r32_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r32_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s8 *tbuf = (s8*)theBuf;
  s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (s8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	res = res * g + b;
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  res = (double)(*tpt) * g + b;
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	res = (double)(*tpt) * g + b;
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (s8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r32_s8 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r32** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r32_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r32_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r32_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s8 *tbuf = (s8*)theBuf;
  register s8 *rbuf = (s8*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + k * tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r32_s8 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r32** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech2DNearestVectorField_r32_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r32_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r32_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u16 *tbuf = (u16*)theBuf;
  u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (u16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    *rbuf = *tpt;
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (u16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r32_u16 ( void* theBuf, /* buffer to be resampled */
			     int *theDim,  /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     r32** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
			     double* mat_aft,  /* transformation matrix */
			     double* mat_bef  /* transformation matrix */
			     )
{
  char *proc = "Reech3DTriLinVectorField_r32_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r32_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r32_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u16 *tbuf = (u16*)theBuf;
  u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (u16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	res = res * g + b;
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (double)(*tpt) * g + b;
	    *rbuf = (u16)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  res = res * g + b;
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  res = res * g + b;
	 *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	res = res * g + b;
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  res = res * g + b;
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	res = res * g + b;
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
	*rbuf = (u16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r32_u16 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r32** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r32_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r32_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r32_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  int rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u16 *tbuf = (u16*)theBuf;
  register u16 *rbuf = (u16*)resBuf;
  
  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;
  
  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\n", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	  
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + iz * tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r32_u16 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r32** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech3DNearestVectorField_r32_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r32_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r32_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u16 *tbuf = (u16*)theBuf;
  u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (u16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  *rbuf = *tpt;
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (u16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r32_u16 ( void* theBuf, /* buffer to be resampled */
						    int *theDim,  /* dimensions of this buffer */
						    void* resBuf, /* result buffer */
						    int *resDim,  /* dimensions of this buffer */
						    r32** theDef, /* deformations */
						    int *defDim, /* dimensions of these buffers */
						    double* mat_aft,  /* transformation matrix */
						    double* mat_bef  /* transformation matrix */
						    )
{
  char *proc = "Reech2DTriLinVectorField_r32_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r32_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r32_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u16 *tbuf = (u16*)theBuf;
  u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (u16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	res = res * g + b;
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  res = (double)(*tpt) * g + b;
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	res = (double)(*tpt) * g + b;
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (u16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r32_u16 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r32** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r32_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r32_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r32_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u16 *tbuf = (u16*)theBuf;
  register u16 *rbuf = (u16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + k * tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r32_u16 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r32** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech2DNearestVectorField_r32_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r32_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r32_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s16 *tbuf = (s16*)theBuf;
  s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (s16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    *rbuf = *tpt;
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (s16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r32_s16 ( void* theBuf, /* buffer to be resampled */
			     int *theDim,  /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     r32** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
			     double* mat_aft,  /* transformation matrix */
			     double* mat_bef  /* transformation matrix */
			     )
{
  char *proc = "Reech3DTriLinVectorField_r32_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r32_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r32_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s16 *tbuf = (s16*)theBuf;
  s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (s16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	res = res * g + b;
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (double)(*tpt) * g + b;
	    *rbuf = (s16)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  res = res * g + b;
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  res = res * g + b;
	 *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	res = res * g + b;
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  res = res * g + b;
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	res = res * g + b;
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
	*rbuf = (s16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r32_s16 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r32** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r32_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r32_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r32_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  int rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s16 *tbuf = (s16*)theBuf;
  register s16 *rbuf = (s16*)resBuf;
  
  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;
  
  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\n", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	  
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + iz * tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r32_s16 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r32** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech3DNearestVectorField_r32_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r32_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r32_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s16 *tbuf = (s16*)theBuf;
  s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (s16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  *rbuf = *tpt;
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (s16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r32_s16 ( void* theBuf, /* buffer to be resampled */
						    int *theDim,  /* dimensions of this buffer */
						    void* resBuf, /* result buffer */
						    int *resDim,  /* dimensions of this buffer */
						    r32** theDef, /* deformations */
						    int *defDim, /* dimensions of these buffers */
						    double* mat_aft,  /* transformation matrix */
						    double* mat_bef  /* transformation matrix */
						    )
{
  char *proc = "Reech2DTriLinVectorField_r32_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r32_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r32_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s16 *tbuf = (s16*)theBuf;
  s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (s16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	res = res * g + b;
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  res = (double)(*tpt) * g + b;
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	res = (double)(*tpt) * g + b;
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (s16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r32_s16 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r32** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r32_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r32_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r32_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s16 *tbuf = (s16*)theBuf;
  register s16 *rbuf = (s16*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + k * tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r32_s16 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r32** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech2DNearestVectorField_r32_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r32_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r32_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  r32 *tbuf = (r32*)theBuf;
  r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (r32 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    *rbuf = *tpt;
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (r32)_CONVERTR_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r32_r32 ( void* theBuf, /* buffer to be resampled */
			     int *theDim,  /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     r32** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
			     double* mat_aft,  /* transformation matrix */
			     double* mat_bef  /* transformation matrix */
			     )
{
  char *proc = "Reech3DTriLinVectorField_r32_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r32_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r32_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  r32 *tbuf = (r32*)theBuf;
  r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (r32 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	res = res * g + b;
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (double)(*tpt) * g + b;
	    *rbuf = (r32)_CONVERTR_( res );
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  res = res * g + b;
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  res = res * g + b;
	 *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	res = res * g + b;
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  res = res * g + b;
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	res = res * g + b;
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
	*rbuf = (r32)_CONVERTR_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r32_r32 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r32** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r32_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r32_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r32_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  int rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  r32 *tbuf = (r32*)theBuf;
  register r32 *rbuf = (r32*)resBuf;
  
  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* defz = theDef[2];
  r32* dbuf;
  
  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\n", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	  
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + iz * tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r32_r32 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r32** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech3DNearestVectorField_r32_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r32_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r32_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  r32 *tbuf = (r32*)theBuf;
  r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (r32 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  *rbuf = *tpt;
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (r32)_CONVERTR_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r32_r32 ( void* theBuf, /* buffer to be resampled */
						    int *theDim,  /* dimensions of this buffer */
						    void* resBuf, /* result buffer */
						    int *resDim,  /* dimensions of this buffer */
						    r32** theDef, /* deformations */
						    int *defDim, /* dimensions of these buffers */
						    double* mat_aft,  /* transformation matrix */
						    double* mat_bef  /* transformation matrix */
						    )
{
  char *proc = "Reech2DTriLinVectorField_r32_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r32_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r32_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  r32 *tbuf = (r32*)theBuf;
  r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (r32 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	res = res * g + b;
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  res = (double)(*tpt) * g + b;
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	res = (double)(*tpt) * g + b;
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (r32)_CONVERTR_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r32_r32 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r32** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r32_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r32_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r32_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r32** theDef = (r32**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  r32 *tbuf = (r32*)theBuf;
  register r32 *rbuf = (r32*)resBuf;

  r32* defx = theDef[0];
  r32* defy = theDef[1];
  r32* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + k * tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r32_r32 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r32** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech2DNearestVectorField_r32_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r32_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r64_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u8 *tbuf = (u8*)theBuf;
  u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (u8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    *rbuf = *tpt;
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (u8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r64_u8 ( void* theBuf, /* buffer to be resampled */
			     int *theDim,  /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     r64** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
			     double* mat_aft,  /* transformation matrix */
			     double* mat_bef  /* transformation matrix */
			     )
{
  char *proc = "Reech3DTriLinVectorField_r64_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r64_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r64_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u8 *tbuf = (u8*)theBuf;
  u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (u8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	res = res * g + b;
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (double)(*tpt) * g + b;
	    *rbuf = (u8)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  res = res * g + b;
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  res = res * g + b;
	 *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	res = res * g + b;
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  res = res * g + b;
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	res = res * g + b;
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
	*rbuf = (u8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r64_u8 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r64** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r64_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r64_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r64_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  int rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u8 *tbuf = (u8*)theBuf;
  register u8 *rbuf = (u8*)resBuf;
  
  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;
  
  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\n", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	  
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + iz * tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r64_u8 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r64** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech3DNearestVectorField_r64_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r64_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r64_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u8 *tbuf = (u8*)theBuf;
  u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (u8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  *rbuf = *tpt;
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (u8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r64_u8 ( void* theBuf, /* buffer to be resampled */
						    int *theDim,  /* dimensions of this buffer */
						    void* resBuf, /* result buffer */
						    int *resDim,  /* dimensions of this buffer */
						    r64** theDef, /* deformations */
						    int *defDim, /* dimensions of these buffers */
						    double* mat_aft,  /* transformation matrix */
						    double* mat_bef  /* transformation matrix */
						    )
{
  char *proc = "Reech2DTriLinVectorField_r64_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r64_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r64_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u8 *tbuf = (u8*)theBuf;
  u8 *tpt;
  register u8 *rbuf = (u8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (u8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	res = res * g + b;
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  res = (double)(*tpt) * g + b;
	  *rbuf = (u8)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	res = (double)(*tpt) * g + b;
	*rbuf = (u8)_CONVERTI_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (u8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r64_u8 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r64** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r64_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r64_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r64_u8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u8 *tbuf = (u8*)theBuf;
  register u8 *rbuf = (u8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + k * tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r64_u8 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r64** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech2DNearestVectorField_r64_u8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r64_u8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r64_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s8 *tbuf = (s8*)theBuf;
  s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (s8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    *rbuf = *tpt;
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (s8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r64_s8 ( void* theBuf, /* buffer to be resampled */
			     int *theDim,  /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     r64** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
			     double* mat_aft,  /* transformation matrix */
			     double* mat_bef  /* transformation matrix */
			     )
{
  char *proc = "Reech3DTriLinVectorField_r64_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r64_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r64_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s8 *tbuf = (s8*)theBuf;
  s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (s8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	res = res * g + b;
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (double)(*tpt) * g + b;
	    *rbuf = (s8)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  res = res * g + b;
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  res = res * g + b;
	 *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	res = res * g + b;
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  res = res * g + b;
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	res = res * g + b;
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
	*rbuf = (s8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r64_s8 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r64** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r64_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r64_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r64_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  int rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s8 *tbuf = (s8*)theBuf;
  register s8 *rbuf = (s8*)resBuf;
  
  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;
  
  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\n", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	  
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + iz * tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r64_s8 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r64** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech3DNearestVectorField_r64_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r64_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r64_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s8 *tbuf = (s8*)theBuf;
  s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (s8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  *rbuf = *tpt;
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (s8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r64_s8 ( void* theBuf, /* buffer to be resampled */
						    int *theDim,  /* dimensions of this buffer */
						    void* resBuf, /* result buffer */
						    int *resDim,  /* dimensions of this buffer */
						    r64** theDef, /* deformations */
						    int *defDim, /* dimensions of these buffers */
						    double* mat_aft,  /* transformation matrix */
						    double* mat_bef  /* transformation matrix */
						    )
{
  char *proc = "Reech2DTriLinVectorField_r64_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r64_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r64_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s8 *tbuf = (s8*)theBuf;
  s8 *tpt;
  register s8 *rbuf = (s8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (s8 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	res = res * g + b;
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  res = (double)(*tpt) * g + b;
	  *rbuf = (s8)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	res = (double)(*tpt) * g + b;
	*rbuf = (s8)_CONVERTI_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (s8)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r64_s8 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r64** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r64_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r64_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r64_s8 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s8 *tbuf = (s8*)theBuf;
  register s8 *rbuf = (s8*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + k * tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r64_s8 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r64** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech2DNearestVectorField_r64_s8";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r64_s8, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r64_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u16 *tbuf = (u16*)theBuf;
  u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (u16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    *rbuf = *tpt;
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (u16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r64_u16 ( void* theBuf, /* buffer to be resampled */
			     int *theDim,  /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     r64** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
			     double* mat_aft,  /* transformation matrix */
			     double* mat_bef  /* transformation matrix */
			     )
{
  char *proc = "Reech3DTriLinVectorField_r64_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r64_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r64_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u16 *tbuf = (u16*)theBuf;
  u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (u16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	res = res * g + b;
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (double)(*tpt) * g + b;
	    *rbuf = (u16)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  res = res * g + b;
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  res = res * g + b;
	 *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	res = res * g + b;
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  res = res * g + b;
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	res = res * g + b;
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
	*rbuf = (u16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r64_u16 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r64** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r64_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r64_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r64_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  int rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  u16 *tbuf = (u16*)theBuf;
  register u16 *rbuf = (u16*)resBuf;
  
  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;
  
  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\n", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	  
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + iz * tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r64_u16 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r64** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech3DNearestVectorField_r64_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r64_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r64_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u16 *tbuf = (u16*)theBuf;
  u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (u16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  *rbuf = *tpt;
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (u16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r64_u16 ( void* theBuf, /* buffer to be resampled */
						    int *theDim,  /* dimensions of this buffer */
						    void* resBuf, /* result buffer */
						    int *resDim,  /* dimensions of this buffer */
						    r64** theDef, /* deformations */
						    int *defDim, /* dimensions of these buffers */
						    double* mat_aft,  /* transformation matrix */
						    double* mat_bef  /* transformation matrix */
						    )
{
  char *proc = "Reech2DTriLinVectorField_r64_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r64_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r64_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u16 *tbuf = (u16*)theBuf;
  u16 *tpt;
  register u16 *rbuf = (u16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (u16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	res = res * g + b;
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  res = (double)(*tpt) * g + b;
	  *rbuf = (u16)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	res = (double)(*tpt) * g + b;
	*rbuf = (u16)_CONVERTI_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (u16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r64_u16 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r64** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r64_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r64_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r64_u16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  u16 *tbuf = (u16*)theBuf;
  register u16 *rbuf = (u16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + k * tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r64_u16 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r64** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech2DNearestVectorField_r64_u16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r64_u16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r64_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s16 *tbuf = (s16*)theBuf;
  s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (s16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    *rbuf = *tpt;
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (s16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r64_s16 ( void* theBuf, /* buffer to be resampled */
			     int *theDim,  /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     r64** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
			     double* mat_aft,  /* transformation matrix */
			     double* mat_bef  /* transformation matrix */
			     )
{
  char *proc = "Reech3DTriLinVectorField_r64_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r64_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r64_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s16 *tbuf = (s16*)theBuf;
  s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (s16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	res = res * g + b;
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (double)(*tpt) * g + b;
	    *rbuf = (s16)_CONVERTI_( res );
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  res = res * g + b;
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  res = res * g + b;
	 *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	res = res * g + b;
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  res = res * g + b;
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	res = res * g + b;
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
	*rbuf = (s16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r64_s16 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r64** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r64_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r64_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r64_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  int rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  s16 *tbuf = (s16*)theBuf;
  register s16 *rbuf = (s16*)resBuf;
  
  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;
  
  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\n", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	  
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + iz * tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r64_s16 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r64** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech3DNearestVectorField_r64_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r64_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r64_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s16 *tbuf = (s16*)theBuf;
  s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (s16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  *rbuf = *tpt;
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (s16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r64_s16 ( void* theBuf, /* buffer to be resampled */
						    int *theDim,  /* dimensions of this buffer */
						    void* resBuf, /* result buffer */
						    int *resDim,  /* dimensions of this buffer */
						    r64** theDef, /* deformations */
						    int *defDim, /* dimensions of these buffers */
						    double* mat_aft,  /* transformation matrix */
						    double* mat_bef  /* transformation matrix */
						    )
{
  char *proc = "Reech2DTriLinVectorField_r64_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r64_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r64_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s16 *tbuf = (s16*)theBuf;
  s16 *tpt;
  register s16 *rbuf = (s16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (s16 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	res = res * g + b;
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  res = (double)(*tpt) * g + b;
	  *rbuf = (s16)_CONVERTI_( res );
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	res = (double)(*tpt) * g + b;
	*rbuf = (s16)_CONVERTI_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (s16)_CONVERTI_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r64_s16 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r64** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r64_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r64_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r64_s16 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  s16 *tbuf = (s16*)theBuf;
  register s16 *rbuf = (s16*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + k * tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r64_s16 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r64** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech2DNearestVectorField_r64_s16";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r64_s16, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DTriLinVectorField_r64_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  r32 *tbuf = (r32*)theBuf;
  r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;
  
  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (r32 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    *rbuf = *tpt;
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      *rbuf = (r32)_CONVERTR_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorField_r64_r32 ( void* theBuf, /* buffer to be resampled */
			     int *theDim,  /* dimensions of this buffer */
			     void* resBuf, /* result buffer */
			     int *resDim,  /* dimensions of this buffer */
			     r64** theDef, /* deformations */
                             int *defDim, /* dimensions of these buffers */
			     double* mat_aft,  /* transformation matrix */
			     double* mat_bef  /* transformation matrix */
			     )
{
  char *proc = "Reech3DTriLinVectorField_r64_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorField_r64_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice

*/

static void *_Reech3DTriLinVectorFieldgb_r64_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double res;
  double v6, v5, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;

  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  r32 *tbuf = (r32*)theBuf;
  r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      iz = (int)z;
      tpt = (r32 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) &&
	   (z > 0.0) && (iz < t1dimz) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dz = z - iz;
	dxdy = dx*dy;
	dxdz = dx*dz;
	dydz = dy*dz;
	dxdydz = dxdy*dz;
	
	/* we have
	   v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	   v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	   v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	   v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	   v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
	v6 = dxdz-dxdydz;
	v5 = dxdy-dxdydz;
	v4 = dx-dxdy-v6;
	
	res = 0;
	res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
	tpt --;
	res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
	tpt -= t1dimx;
	res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
	tpt --;
	res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
	tpt -= toffset2;
	res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	tpt --;
	res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt -= t1dimx;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt --;
	res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	res = res * g + b;
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      tpt += ix + iy * tdimx + iz * tdimxy;
      if ( (x < 0.0) || (ix == t1dimx) ) {
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  if ( (z < 0.0) || (iz == t1dimz) ) {
	    res = (double)(*tpt) * g + b;
	    *rbuf = (r32)_CONVERTR_( res );
	    continue;
	  }
	  dz = z - iz;
	  res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	  tpt += tdimxy;
	  res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	  res = res * g + b;
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	dy = y - iy;
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	  tpt += tdimx;
	  res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	  res = res * g + b;
	 *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
	tpt += toffset2+1;
	res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt += tdimx;
	res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
	res = res * g + b;
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      /* here we are sure that the border is either
	 along the Y or the Z axis */
      dx = x - ix;
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	  tpt ++;
	  res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	  res = res * g + b;
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	dz = z - iz;
	res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
	tpt += tdimxy-1;
	res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
	tpt ++;
	res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
	res = res * g + b;
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      /* here we are sure that the border is along the Z axis */
      dy = y - iy;
      res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += t1dimx;
      res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt ++;
      res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
      res = res * g + b;
	*rbuf = (r32)_CONVERTR_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DTriLinVectorFieldgb_r64_r32 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r64** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech3DTriLinVectorFieldgb_r64_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech3DTriLinVectorFieldgb_r64_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech3DNearestVectorField_r64_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy, iz;
  
  double xd, yd, zd, x, y, z;
  double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  double v[3];
  double v6, v5, v4;
  
  int rdimx=resDim[0], rdimy=resDim[1];
  
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  
  int ddimx=defDim[0], ddimy=defDim[1], ddimz=defDim[2];
  int ddimxy = ddimx * ddimy;
  int doffset1=ddimxy+ddimx+1, doffset2=ddimxy-ddimx-1;
  int d1dimx=ddimx-1, d1dimy=ddimy-1, d1dimz=ddimz-1;
  
  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  double borddimz = (double)tdimz-0.5;
  r32 *tbuf = (r32*)theBuf;
  register r32 *rbuf = (r32*)resBuf;
  
  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* defz = theDef[2];
  r64* dbuf;
  
  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;
  defz += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\n", k );
    
    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 ) {
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {

      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	zd = (double)k + *defz;
	defx ++;
	defy ++;
	defz ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[ 2] * k + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[ 6] * k + mat_bef[7];
	z = mat_bef[8] * i +  mat_bef[9] * j + mat_bef[10] * k + mat_bef[11];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	iz = (int)z;
	
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5)
	     || ( z <= -0.5 ) || ( z >= ddimz-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) &&
	     (z > 0.0) && (iz < d1dimz) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dz = z - iz;
	  dxdy = dx*dy;
	  dxdz = dx*dz;
	  dydz = dy*dz;
	  dxdydz = dxdy*dz;
	  
	  /* we have
	     v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	     v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	     v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	     v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	     v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v6 = dxdz-dxdydz;
	  v5 = dxdy-dxdydz;
	  v4 = dx-dxdy-v6;
	  
	  for ( l=0; l<3; l++ ) {
	    v[l] = 0;
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + iz * ddimxy + doffset1;
	    v[l] += dxdydz * (*dbuf);            /* tbuf(ix+1,iy+1,iz+1) */
	    dbuf --;
	    v[l] += (dydz-dxdydz) * (*dbuf);     /* tbuf(ix  ,iy+1,iz+1) */
	    dbuf -= d1dimx;
	    v[l] += v6 * (*dbuf);                /* tbuf(ix+1  ,iy,  iz+1) */
	    dbuf --;
	    v[l] += (dz-dydz-v6) * (*dbuf);      /* tbuf(ix  ,iy  ,iz+1) */
	    dbuf -= doffset2;
	    v[l] += v5 * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	    dbuf --;
	    v[l] += (dy-dydz-v5) * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf -= d1dimx;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf --;
	    v[l] += (1-dy-dz+dydz-v4) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	  }
	  
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  
	  if ( (x < 0.0) || (ix == d1dimx) ) {
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = *dbuf;
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dz) * (*dbuf); /* (1-dz)* tbuf(ix,iy,iz) */
		  dbuf += ddimxy;
		  v[l] += dz * (*dbuf);     /* dz * tbuf(ix,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dy)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf += ddimx;
		  v[l] += dy*(1-dz) * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		  dbuf += doffset2+1;
		  v[l] += (1-dy)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf += ddimx;
		  v[l] += dy*dz * (*dbuf);        /* tbuf(ix,iy+1,iz+1) */
		}
	      }
	    }
	  }
	  else {
	    /* here we are sure that the border is either
	       along the Y or the Z axis */
	    dx = x - ix;
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      if ( (z < 0.0) || (iz == d1dimz) ) {
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		}
	      }
	      else {
		dz = z - iz;
		for ( l=0; l<3; l++ ) {
		  v[l] = 0;
		  dbuf = theDef[l];
		  dbuf += ix + iy * ddimx + iz * ddimxy;
		  v[l] = (1-dx)*(1-dz) * (*dbuf); /* tbuf(ix,iy,iz) */
		  dbuf ++;
		  v[l] += dx*(1-dz) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		  dbuf += ddimxy-1;
		  v[l] += (1-dx)*dz * (*dbuf);    /* tbuf(ix,iy,iz+1) */
		  dbuf ++;
		  v[l] += dx*dz * (*dbuf);        /* tbuf(ix+1,iy,iz+1) */
		}
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<3; l++ ) {
		v[l] = 0;
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + iz * ddimxy;
		v[l] = (1-dx)*(1-dy) * (*dbuf); /* tbuf(ix,iy,iz) */
		dbuf ++;
		v[l] += dx*(1-dy) * (*dbuf);    /* tbuf(ix+1,iy,iz) */
		dbuf += d1dimx;
		v[l] += (1-dx)*dy * (*dbuf);    /* tbuf(ix,iy+1,iz) */
		dbuf ++;
		v[l] += dx*dy * (*dbuf);        /* tbuf(ix+1,iy+1,iz) */
	      }
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	zd = z + v[2];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = zd;
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[2] * zd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[6] * zd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
	z = mat_aft[8] * xd +  mat_aft[9] * yd + mat_aft[10] * zd + mat_aft[11];
	if (( z <= -0.5 ) || ( z >= borddimz)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      iz = (int)(z+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + iz * tdimxy ];
    }
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech3DNearestVectorField_r64_r32 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r64** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech3DNearestVectorField_r64_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech3DNearestVectorField_r64_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}






static void *_Reech2DTriLinVectorField_r64_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  r32 *tbuf = (r32*)theBuf;
  r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (r32 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  *rbuf = *tpt;
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      *rbuf = (r32)_CONVERTR_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorField_r64_r32 ( void* theBuf, /* buffer to be resampled */
						    int *theDim,  /* dimensions of this buffer */
						    void* resBuf, /* result buffer */
						    int *resDim,  /* dimensions of this buffer */
						    r64** theDef, /* deformations */
						    int *defDim, /* dimensions of these buffers */
						    double* mat_aft,  /* transformation matrix */
						    double* mat_bef  /* transformation matrix */
						    )
{
  char *proc = "Reech2DTriLinVectorField_r64_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorField_r64_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DTriLinVectorFieldgb_r64_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef;
  float gain = p->gain; 
  float bias = p->bias; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double res;
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;
  int t1dimx=tdimx-1, t1dimy=tdimy-1;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  r32 *tbuf = (r32*)theBuf;
  r32 *tpt;
  register r32 *rbuf = (r32*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  register double b=bias;
  register double g=gain;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)x;
      iy = (int)y;
      tpt = (r32 *)tbuf;
      
      /* are we on the border or not ? */
      if ( (x > 0.0) && (ix < t1dimx) &&
	   (y > 0.0) && (iy < t1dimy) ) {
	/* the corresponding point is in the box defined 
	   by (ix[+1],iy[+1],iz[+1]) */
	dx = x - ix;
	dy = y - iy;
	dxdy = dx*dy;
	
	/* we have
	   v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	   v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	   v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	   v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	*/
	tpt += ix + iy * tdimx + k * tdimxy;

	v1 = dy-dxdy;
	v4 = dx-dxdy;
	
	res = 0;
	res += (1-dx-v1) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
	tpt ++;
	res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
	tpt += t1dimx;
	res += (v1) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
	tpt ++;
	res += dxdy * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
	res = res * g + b;
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      /* here, we are sure we are on some border */
      if ( (x < 0.0) || (ix == t1dimx) ) {
	/* we just look at y */
	if ( (y < 0.0) || (iy == t1dimy) ) {
	  res = (double)(*tpt) * g + b;
	  *rbuf = (r32)_CONVERTR_( res );
	  continue;
	}
	dy = y - iy;
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1) */
	res = (double)(*tpt) * g + b;
	*rbuf = (r32)_CONVERTR_( res );
	continue;
      }
      dx = x - ix;
      res  = (1-dx) * (*tpt); /* (1-dx)* tbuf(ix,iy) */
      tpt ++;
      res += dx * (*tpt);     /* dx * tbuf(ix+1,iy) */
      res = res * g + b;
      *rbuf = (r32)_CONVERTR_( res );
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DTriLinVectorFieldgb_r64_r32 ( void* theBuf, /* buffer to be resampled */
						      int *theDim,  /* dimensions of this buffer */
						      void* resBuf, /* result buffer */
						      int *resDim,  /* dimensions of this buffer */
						      r64** theDef, /* deformations */
						      int *defDim, /* dimensions of these buffers */
						      double* mat_aft,  /* transformation matrix */
						      double* mat_bef,  /* transformation matrix */
						      float gain,
						      float bias )
{
  char *proc = "Reech2DTriLinVectorFieldgb_r64_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = gain;
  p.bias = bias;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  fprintf( stderr, "%s: %d chunks\n", proc, chunks.n_allocated_chunks );

  /* processing
   */
  if ( processChunks( &_Reech2DTriLinVectorFieldgb_r64_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}





static void *_Reech2DNearestVectorField_r64_r32 ( void *par )
{
  typeChunk *chunk = (typeChunk *)par;
  void *parameter = chunk->parameters;
  size_t first = chunk->first;
  size_t last = chunk->last;

  _VectorFieldResamplingParam *p = (_VectorFieldResamplingParam *)parameter;

  void* theBuf = p->theBuf;
  int *theDim = p->theDim;
  void* resBuf = p->resBuf;
  int *resDim = p->resDim;
  r64** theDef = (r64**)p->theDef;
  int *defDim = p->defDim;
  double* mat_aft = p->mat_aft; 
  double* mat_bef = p->mat_bef; 

  int i, j, k, l, ix, iy;
  
  double xd, yd, x, y;
  double dx, dy, dxdy;
  double v[2];
  double v1, v4;

  int rdimx=resDim[0], rdimy=resDim[1];

  int tdimx=theDim[0], tdimy=theDim[1];
  int tdimxy=tdimx*tdimy;

  int ddimx=defDim[0], ddimy=defDim[1];
  int ddimxy = ddimx * ddimy;
  int d1dimx=ddimx-1, d1dimy=ddimy-1;

  double borddimx = (double)tdimx-0.5, borddimy = (double)tdimy-0.5;
  r32 *tbuf = (r32*)theBuf;
  register r32 *rbuf = (r32*)resBuf;

  r64* defx = theDef[0];
  r64* defy = theDef[1];
  r64* dbuf;

  int ifirst, jfirst, kfirst;
  int ilast, jlast, klast;

  k = kfirst = first / (rdimx*rdimy);
  j = jfirst = (first - kfirst*(rdimx*rdimy)) / rdimx;
  i = ifirst = (first - kfirst*(rdimx*rdimy) - jfirst*rdimx);

  klast = last / (rdimx*rdimy);
  jlast = (last - klast*(rdimx*rdimy)) / rdimx;
  ilast = (last - klast*(rdimx*rdimy) - jlast*rdimx);

  rbuf += first;
  defx += first;
  defy += first;

  if ( mat_bef == NULL ) {
    if ( resDim[0] != defDim[0] || resDim[1] != defDim[1] || resDim[2] != defDim[2] ) {
      fprintf( stderr, "deformation field should have the same dimension than result image\n" );
      chunk->ret = -1;
      return( (void*)NULL );
    }
  }

  for ( ; k<=klast; k++, j=0 ) {
    if ( _verbose_ > 1 )
      fprintf( stderr, "Processing slice %d\r", k );

    for ( ; (j<rdimy && k<klast) || (j<=jlast && k==klast); j++, i=0 )
    for ( ; (i<rdimx && (k<klast || (j<jlast && k==klast))) || (i<=ilast && j==jlast && k==klast); i++, rbuf++ ) {
	
      /* computation of the corresponding point after deformation */
      if ( mat_bef == NULL ) {
	xd = (double)i + *defx;
	yd = (double)j + *defy;
	defx ++;
	defy ++;
      }
      else {
	
	/* apply the first matrix */
	x = mat_bef[0] * i +  mat_bef[1] * j + mat_bef[3];
	y = mat_bef[4] * i +  mat_bef[5] * j + mat_bef[7];
	
	/* interpolate the vector deformation at (xd,yd,zd) */
	ix = (int)x;
	iy = (int)y;
	
	/* the point is outside the deformation field 
	 */
	if ( ( x <= -0.5 ) || ( x >= ddimx-0.5)
	     || ( y <= -0.5 ) || ( y >= ddimy-0.5) ) {
	  *rbuf = 0; 
	  continue; 
	}
	
	/* vector interpolation: are we on the border or not ? */
	if ( (x > 0.0) && (ix < d1dimx) &&
	     (y > 0.0) && (iy < d1dimy) ) {
	  /* the corresponding point is in the box defined 
	     by (ix[+1],iy[+1],iz[+1]) */
	  dx = x - ix;
	  dy = y - iy;
	  dxdy = dx*dy;
	  
	  /* we have
	     v[5]=dxdy;         coefficient of tbuf(ix+1,iy+1,iz  )
	     v[4]=dx-dxdy;      coefficient of tbuf(ix+1,iy  ,iz  )
	     v[1]=dy-dxdy;      coefficient of tbuf(ix  ,iy+1,iz  )
	     v[0]=1-dx-dy+dxdy; coefficient of tbuf(ix  ,iy  ,iz  )
	  */
	  
	  v1 = dy-dxdy;
	  v4 = dx-dxdy;

	  for ( l=0; l<2; l++ ) {
	    dbuf = theDef[l];
	    dbuf += ix + iy * ddimx + k * ddimxy;
	    v[l] = 0;
	    v[l] += (1-dx-v1) * (*dbuf); /* tbuf(ix  ,iy  ,iz  ) */
	    dbuf ++;
	    v[l] += v4 * (*dbuf);                /* tbuf(ix+1,iy  ,iz  ) */
	    dbuf += d1dimx;
	    v[l] += v1 * (*dbuf);      /* tbuf(ix  ,iy+1,iz  ) */
	    dbuf ++;
	    v[l] += dxdy * (*dbuf);                /* tbuf(ix+1,iy+1,iz  ) */
	  }
	}
	else {
	  
	  /* here, we are sure we are on some border */
	  if ( (x < 0.0) || (ix == d1dimx) ) {

	    /* we just look at y */
	    if ( (y < 0.0) || (iy == d1dimy) ) {
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l] = *dbuf;
	      }
	    }
	    else {
	      dy = y - iy;
	      for ( l=0; l<2; l++ ) {
		dbuf = theDef[l];
		dbuf += ix + iy * ddimx + k * ddimxy;
		v[l]  = (1-dy) * (*dbuf); /* (1-dy)* tbuf(ix,iy) */
		dbuf += d1dimx;
		v[l] += dy * (*dbuf);     /* dy * tbuf(ix,iy+1) */
	      }
	    }
	  }
	  else {
	    dx = x - ix;
	    for ( l=0; l<2; l++ ) {
	      dbuf = theDef[l];
	      dbuf += ix + iy * ddimx + k * ddimxy;
	      v[l]  = (1-dx) * (*dbuf); /* (1-dx)* tbuf(ix,iy) */
	      dbuf ++;
	      v[l] += dx * (*dbuf);     /* dx * tbuf(ix+1,iy) */
	    }
	  }
	}
	
	xd = x + v[0];
	yd = y + v[1];
	
      } /* ( mat_bef != NULL ) */
      
      /* computation of the corresponding point after matrix application */
      if ( mat_aft == NULL ) {
	x = xd;
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = yd;
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      else {
	x = mat_aft[0] * xd +  mat_aft[1] * yd + mat_aft[3];
	if (( x <= -0.5 ) || ( x >= borddimx)) { *rbuf = 0; continue; }
	y = mat_aft[4] * xd +  mat_aft[5] * yd + mat_aft[7];
	if (( y <= -0.5 ) || ( y >= borddimy)) { *rbuf = 0; continue; }
      }
      
      /* here, the point lies on the borders or completely inside
	 the image */
      ix = (int)(x+0.5);
      iy = (int)(y+0.5);
      
      *rbuf = tbuf[ ix + iy * tdimx + k * tdimxy ];
      
    }
  }
  chunk->ret = 1;
  return( (void*)NULL );
}





extern void Reech2DNearestVectorField_r64_r32 ( void* theBuf, /* buffer to be resampled */
						     int *theDim,  /* dimensions of this buffer */
						     void* resBuf, /* result buffer */
						     int *resDim,  /* dimensions of this buffer */
						     r64** theDef, /* deformations */
						     int *defDim, /* dimensions of these buffers */
						     double* mat_aft,  /* transformation matrix */
						     double* mat_bef  /* transformation matrix */
						     )
{
  char *proc = "Reech2DNearestVectorField_r64_r32";
  size_t first = 0;
  size_t last;
  int i;
  typeChunks chunks;
  _VectorFieldResamplingParam p;

  /* preparing parallelism
   */
  first = 0;
  last = (size_t)resDim[2] * (size_t)resDim[1] * (size_t)resDim[0] - 1;
  initChunks( &chunks );
  if ( buildChunks( &chunks, first, last, proc ) != 1 ) {
    if ( _verbose_ )
      fprintf( stderr, "%s: unable to compute chunks\n", proc );
    return;
  }

  p.theBuf = theBuf;
  p.theDim = theDim;
  p.resBuf = resBuf;
  p.resDim = resDim;
  p.theDef = (void**)theDef;
  p.defDim = defDim;
  p.mat_aft = mat_aft;
  p.mat_bef = mat_bef;
  p.gain = 1.0;
  p.bias = 0.0;

  for ( i=0; i<chunks.n_allocated_chunks; i++ ) 
    chunks.data[i].parameters = (void*)(&p);
  
  /* processing
   */
  if ( processChunks( &_Reech2DNearestVectorField_r64_r32, &chunks, proc ) != 1 ) {
      if ( _verbose_ )
	fprintf( stderr, "%s: unable to resample image\n", proc );
      freeChunks( &chunks );
      return;
  }

   freeChunks( &chunks );
}
